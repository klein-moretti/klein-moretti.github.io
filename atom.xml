<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://klein-moretti.github.io</id>
    <title>Gridea</title>
    <updated>2019-12-11T12:16:12.748Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://klein-moretti.github.io"/>
    <link rel="self" href="https://klein-moretti.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://klein-moretti.github.io/images/avatar.png</logo>
    <icon>https://klein-moretti.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[Spring Framework总结]]></title>
        <id>https://klein-moretti.github.io/post/spring-framework-zong-jie</id>
        <link href="https://klein-moretti.github.io/post/spring-framework-zong-jie">
        </link>
        <updated>2018-11-28T12:13:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="springioc">SpringIOC</h1>
<h2 id="ioc容器概念">IOC容器概念</h2>
<p>IOC其实就是一个对象的容器。全称Inversion Of Control 控制反转，核心的作用就是将原来由开发人员来控制的对象管理操作交由Spring来管理。</p>
<p>SpringIOC不仅帮我们管理了对象的创建，还包括给对象增加了生命周期行为、作用域(单例、非单例)、懒加载。 配合Spring的DI， 更能方便的解决对象属性值注入、对象之间的依赖注入问题。</p>
<h2 id="ioc容器初始化方式">IOC容器初始化方式</h2>
<h3 id="classpathxmlapplicationcontext">ClassPathXmlApplicationContext</h3>
<p>加载类路径下的xml配置文件的方式，去初始化IOC容器上下文</p>
<pre><code class="language-java">// 加载单个xml配置，初始化上下文
ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext1.xml&quot;);

// 加载多个xml配置，初始化上下文
ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(new String[]{&quot;applicationContext1.xml&quot;, &quot;applicationContext2.xml&quot;});

// 加载当前运行类所在的类路径下所有以application开头的配置文件
ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;appliction*.xml&quot;);

// 加载工程中所有类路径下所有以application开头的配置文件
ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath*:appliction*.xml&quot;);

// 加载工程中所有类路径下所有以application或spring开头的配置文件
ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(new String[]{&quot;classpath*:appliction*.xml&quot;, &quot;classpath*:spring*.xml&quot;});
</code></pre>
<blockquote>
<p>配置文件路径中可以包含通配符(*)和前缀(classpath*:，代表所有类路径，包括源码类路径和单元测试类路径)</p>
</blockquote>
<h3 id="annotationconfigapplicationcontext">AnnotationConfigApplicationContext</h3>
<p>加载通过Java注解方式配置的Bean上下文。</p>
<pre><code class="language-java">// 加载单个注解配置，初始化上下文
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(MyConfiguration.class);

// 加载多个注解配置，初始化上下文
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(new Class[]{MyConfiguration1.class, MyConfiguration2.class});
</code></pre>
<h2 id="bean初始化方式">Bean初始化方式</h2>
<h3 id="构造方法方式最常用">构造方法方式（最常用）</h3>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;com.test.StudentDao&quot; /&gt;
</code></pre>
<h3 id="静态工厂方法">静态工厂方法</h3>
<pre><code class="language-xml">&lt;!-- 
	class：指定的是静态工厂类，而不是将要创建的对象类型
	factory-method: 指定的是工厂中的静态方法 
--&gt;
&lt;bean id=&quot;xx&quot; class=&quot;com.test.StudentDaoFactory&quot; factory-method=&quot;createDao&quot; /&gt;
</code></pre>
<h3 id="实例工厂方法">实例工厂方法</h3>
<pre><code class="language-xml">&lt;!-- 
	class：指定的是实例工厂类 
--&gt;
&lt;bean id=&quot;xxFactory&quot; class=&quot;com.test.StudentDaoFactory&quot; /&gt;
&lt;!-- 
	factory-bean：指定的是实例工厂对象
	factory-method: 指定的是工厂中的实例方法 
--&gt;
&lt;bean id=&quot;xx&quot; factory-bean=&quot;xxFactory&quot; factory-method=&quot;createDao&quot; /&gt;
</code></pre>
<h2 id="bean的命名">Bean的命名</h2>
<p>在XML中配置中可以通过<bean>标签上的id、name属性值给一个bean命名，以便在其他地方引用。</p>
<p>id属性： bean的唯一名称，只允许出现一个值。且同一个IOC容器中不允许出现两个id值一样的bean。</p>
<p>name属性： 和id类似也是给bean命名。但是name属性的值可以有多个，多个值之间使用英文逗号(,)或者英文分号(;)或者空格符隔开</p>
<h2 id="bean的作用域">Bean的作用域</h2>
<ul>
<li>
<p>prototype</p>
<p>在SpringIOC中prototype scope的意思指的是非单例，就是每次使用该bean的时候都会重新创建一个对象。</p>
<figure data-type="image" tabindex="1"><img src="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/images/prototype.png" alt="原型作用域示意图"></figure>
</li>
<li>
<p>singleton(默认)</p>
<p>singleton作用域是IOC中默认的作用域，代表单例。每次使用bean的时候，不会重新创建对象，在整个IOC容器中该类型的对象只有一个。</p>
<figure data-type="image" tabindex="2"><img src="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/images/singleton.png" alt="单例作用域示意图"></figure>
</li>
</ul>
<h2 id="bean的生命周期">Bean的生命周期</h2>
<ul>
<li>
<p>Singleton Bean的生命周期</p>
<ul>
<li>初始化时机： 在IOC容器初始化时，就会把配置的所有单例bean实例化。</li>
<li>销毁时机：在IOC容器销毁时，所有bean的销毁方法会被调用。</li>
</ul>
</li>
<li>
<p>Prototype Bean的生命周期</p>
<ul>
<li>初始化时机： 在实际使用该bean的时候，比如：getBean、获取依赖此bean的其他bean需要使用</li>
<li>销毁时机： 在IOC容器销毁时。（但是通过destroy-method指定的声明周期方法不会被调用，也就是说Spring不提供prototypebean完整的生命周期管理）</li>
</ul>
</li>
<li>
<p>如何指定生命周期的回调方法</p>
<ul>
<li>xml中的init-method、destroy-method</li>
<li>注解方式@PostConstrutor、@PreDestroy</li>
</ul>
</li>
<li>
<p>指定默认的声明周期回调方法</p>
<ul>
<li>在xml中，通过在beans标签上添加default-init-method、default-destory-method来指定</li>
<li>在注解配置中，没有对应的方法可以设置所有bean默认的生命周期回调</li>
</ul>
</li>
</ul>
<h2 id="bean懒加载">Bean懒加载</h2>
<p>lazy-init属性</p>
<p>默认是false</p>
<blockquote>
<p>懒加载配置主要是针对单例的bean，因为它默认是在容器初始化时就被实例化了。</p>
</blockquote>
<h2 id="如何优雅的停止非web-spring应用">如何优雅的停止非Web Spring应用</h2>
<p>添加一个shutdown hook。所有派生自ConfigurableApplicationContext接口的实现类都支持此方法</p>
<pre><code class="language-java">ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;xxx.xml&quot;);

ctx.registerShutdownHook(); //注册停止回调
</code></pre>
<h1 id="spring-di">Spring DI</h1>
<h2 id="概述">概述</h2>
<p>DI的全称是Dependency Injection（依赖注入）。IOC是将我们工程中的所有对象交由Spring来管理，DI是此基础，将对象中的属性、依赖的其他对象也管理起来，自动注入到由Spring帮我们管理的对象中。</p>
<blockquote>
<p>将要注入的对象和目标对象都必须是由SpringIOC管理的bean.</p>
</blockquote>
<h2 id="di的细节实现">DI的细节实现</h2>
<h3 id="构造参数注入">构造参数注入</h3>
<p>将一个bean创建过程中构造方法需要的参数，通过Spring DI的方式，自动注入到构造方法中。</p>
<h3 id="setter注入">Setter注入</h3>
<p>先通过一个无参的构造方法创建对象，然后通过属性的setter方法，将属性值注入到对象上。</p>
<h3 id="支持注入的类型">支持注入的类型</h3>
<ul>
<li>
<p>普通字面量</p>
<ul>
<li>String</li>
<li>Integer(int)</li>
<li>Long(long)</li>
<li>Byte(byte)</li>
<li>...</li>
</ul>
</li>
<li>
<p>集和类型</p>
<ul>
<li>
<p>List</p>
<pre><code class="language-xml">&lt;bean id=&quot;xxx&quot; class=&quot;xx.xxx.xxx.AA&quot;&gt;&lt;/bean&gt;
&lt;bean&gt;
    &lt;property name=&quot;hobbies&quot;&gt;
    	&lt;list&gt;
        	&lt;value&gt;简单类型值&lt;/value&gt;
            &lt;bean&gt;内部bean&lt;/bean&gt;
            &lt;ref bean=&quot;xxx&quot; /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>Map</p>
<pre><code class="language-xml">&lt;bean id=&quot;xxx&quot; class=&quot;xx.xxx.xxx.AA&quot;&gt;&lt;/bean&gt;
&lt;bean&gt;
    &lt;property name=&quot;gameTitle&quot;&gt;
    	&lt;map&gt;
        	&lt;entry key=&quot;王者荣耀&quot; value=&quot;荣耀王者&quot; /&gt;
            &lt;entry key=&quot;王者荣耀&quot; value-ref=&quot;xxx&quot; /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>Set</p>
<pre><code class="language-xml">&lt;bean id=&quot;xxx&quot; class=&quot;xx.xxx.xxx.AA&quot;&gt;&lt;/bean&gt;
&lt;bean&gt;
    &lt;property name=&quot;hobbies&quot;&gt;
    	&lt;!-- set用法和List类似， 里面可以注入普通字面量值、也可以是一个bean引用，或者内部bean、或者是一个set、list、Properties  --&gt;
        &lt;set&gt;
        	&lt;value&gt;简单类型值&lt;/value&gt;
            &lt;bean&gt;内部bean&lt;/bean&gt;
            &lt;ref bean=&quot;xxx&quot; /&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>java.util.Properties</p>
<pre><code class="language-xml">&lt;!-- props标签是用来注入java.util.Properties类型的属性，用法和map类似，但是属性值是在标签中间写 --&gt;
&lt;property name=&quot;gameNick&quot;&gt;
    &lt;props&gt;
        &lt;prop key=&quot;王者荣耀&quot;&gt;最擅长1V5&lt;/prop&gt;
        &lt;prop key=&quot;吃鸡&quot;&gt;一枪爆头&lt;/prop&gt;
    &lt;/props&gt;
&lt;/property&gt;
</code></pre>
</li>
<li>
<p>注入空置、空字符串</p>
<pre><code class="language-xml">&lt;property name=&quot;gameNick&quot;&gt;
    &lt;null /&gt;
&lt;/property&gt;


&lt;property name=&quot;gameNick&quot; value=&quot;&quot; /&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="自动装配">自动装配</h3>
<h5 id="自动装配支持的策略">自动装配支持的策略</h5>
<ul>
<li>
<p>byType</p>
<p>按照类型去IOC容器中找需要的bean，如果找到一个，则自动装配；如果没找到，不注入此属性；如果找到了多个匹配类型的bean，就会报错。</p>
</li>
<li>
<p>byName</p>
<p>按照名称去IOC容器中找需要的bean，如果找到就自动注入；如果没找到，不注入此属性。</p>
</li>
<li>
<p>constructor</p>
<p>工作原理和byType类似，也是按照类型去IOC容器中找对应的bean。不同的是注入的地方不是setter，而是构造方法的参数。</p>
</li>
<li>
<p>no  （默认值）</p>
<p>如果没有打开自动注入，默认Spring不会自动装配需要的属性。</p>
</li>
</ul>
<h2 id="xml方式的di">XML方式的DI</h2>
<h3 id="构造参数注入-2">构造参数注入</h3>
<ul>
<li>
<p>常规写法</p>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;&quot; /&gt;
&lt;bean class=&quot;com.test.XXX&quot;&gt;
	&lt;constructor-arg name=&quot;age&quot; value=&quot;45&quot; /&gt;
    &lt;constructor-arg name=&quot;x&quot; ref=&quot;xx&quot; /&gt;  &lt;!-- 注入引用的bean --&gt;
    &lt;constructor-arg name=&quot;&quot;&gt;	&lt;!-- 注入内部bean --&gt;
    	&lt;bean&gt;&lt;/bean&gt;
    &lt;/constructor-arg&gt;
    &lt;constructor-arg name=&quot;&quot;&gt;	&lt;!-- 注入list类型构造参数 --&gt;
    	&lt;list&gt;
        	
        &lt;/list&gt;
    &lt;/constructor-arg&gt;
    ....
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>c命名空间简写</p>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;&quot; /&gt;
&lt;bean class=&quot;com.test.XXX&quot; c:age=&quot;45&quot; c:x-ref=&quot;xx&quot; /&gt;
</code></pre>
</li>
</ul>
<h3 id="setter方式注入">setter方式注入</h3>
<p>setter注入能够注入的类型以及写法基本和构造参数注入时的写法一致，只不过将<construtor-arg>标签换成了<property></p>
<ul>
<li>
<p>常规用法</p>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;&quot; /&gt;
&lt;bean class=&quot;com.test.XXX&quot;&gt;
	&lt;property name=&quot;age&quot; value=&quot;45&quot; /&gt;
    &lt;property name=&quot;x&quot; ref=&quot;xx&quot; /&gt;  &lt;!-- 注入引用的bean --&gt;
    &lt;property name=&quot;&quot;&gt;	&lt;!-- 注入内部bean --&gt;
    	&lt;bean&gt;&lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name=&quot;&quot;&gt;	&lt;!-- 注入list类型构造参数 --&gt;
    	&lt;list&gt;
        	
        &lt;/list&gt;
    &lt;/property&gt;
    ....
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>p命名空间简写</p>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;&quot; /&gt;
&lt;bean class=&quot;com.test.XXX&quot; p:age=&quot;45&quot; p:x-ref=&quot;xx&quot; /&gt;
</code></pre>
</li>
</ul>
<h3 id="开启自动装配">开启自动装配</h3>
<pre><code class="language-xml">&lt;!-- 
通过给当前的bean添加autowire属性开启自动注入
可选的值：参见自动装配章节
 --&gt;
&lt;bean id=&quot;xx&quot; class=&quot;&quot; autowire=&quot;&quot; /&gt;
</code></pre>
<h3 id="提高自动装配时的权重">提高自动装配时的权重</h3>
<pre><code class="language-xml">&lt;!-- 当其他的bean中需要注入一个Test类型的属性，而满足条件的bean有多个时，会优先注入primary=&quot;true&quot;的bean --&gt;
&lt;bean id=&quot;xx&quot; class=&quot;com.Test&quot; primary=&quot;true&quot; /&gt;
</code></pre>
<h3 id="按类型自动装配时不参与候选">按类型自动装配时，不参与候选</h3>
<pre><code class="language-xml">&lt;!-- 当其他的bean中需要注入一个Test类型的属性，而满足条件的bean有多个时，autowire-candidate=&quot;false&quot;的bean会自动退出候选序列 --&gt;
&lt;bean id=&quot;xx&quot; class=&quot;com.Test&quot; autowire-candidate=&quot;false&quot; /&gt;
</code></pre>
<h2 id="注解方式的di">注解方式的DI</h2>
<ul>
<li>
<p>构造参数注入</p>
<p>在构造方法上添加 <code>@Autowired</code>注解，构造方法的参数就会自动注入进来</p>
</li>
<li>
<p>setter方法注入</p>
<p>方法有两种：</p>
<ol>
<li>在属性的setter方法上添加<code>@Autowired</code>注解</li>
<li>在属性上添加<code>@Autowired</code>注解</li>
</ol>
</li>
</ul>
<h3 id="提高自动装配时的权重-2">提高自动装配时的权重</h3>
<pre><code class="language-java">@Primary
@Component
public class Test {


}

public class Main {
    
    @Primary
    @Bean
    public void test() {
        return new Test();
    }
    
}
</code></pre>
<h1 id="springaop">SpringAOP</h1>
<h2 id="概述-2">概述</h2>
<p>AOP的全称是Aspect Oriented  Programming(面向切面编程)</p>
<p>OOP语言提供了类与类之间纵向的关系（继承、接口），而AOP补充了横向的关系（比如在不改变目标类中源代码的情况下给com.john.demo.dao包下所有类中以insert和update开头的方法添加事务管理）</p>
<h3 id="springaop和aspectj的区别">SpringAOP和AspectJ的区别</h3>
<p>AspectJ是一个专门主打面向切面编程的框架。 它是使用一种特殊的语言(扩展自Java语言)来编写切面代码，后缀是.aj格式，并且需要使用专门的编译器将其编译成jvm可以运行的class文件。</p>
<p>SpringAOP底层也是使用了AspectJ的方案，但是在上层做了很多封装层面的工作，可以让开发人员直接使用Java代码来编写切面。并且由于使用的是标准的Java语言，所以并不需要在额外安装一个专门的编译器。但是由于开发人员直接接触的是Spring AOP，那么凡是Spring中没有实现的那些AOP功能，我们就用不了了，这种情况下只能跟产品经理撕逼或者去学习原生的AspectJ。</p>
<h2 id="aop的术语">AOP的术语</h2>
<ul>
<li>
<p>切面（Aspect）</p>
<p>简单来说，切面就是我们要往目标代码中插入进去的代码。</p>
</li>
<li>
<p>连接点（Join Pointer）</p>
<p>理论上所有可能会被切入的地方都可以称之为连接点</p>
</li>
<li>
<p>切入点(Pointcut)</p>
<p>选择某个连接点切入，将切面代码织入进去。这个连接点就叫做切入点。</p>
</li>
<li>
<p>织入(Weaving)</p>
<p>把切面代码糅合到目标代码中的过程就是织入。</p>
</li>
<li>
<p>通知(Advice)</p>
<p>通知决定了切面代码织入到目标代码中后，运行的时机(比如是在目标方法执行前，还是执行后)。</p>
</li>
</ul>
<h2 id="在spring中使用aop">在Spring中使用AOP</h2>
<h3 id="基于xml方式使用">基于XML方式使用</h3>
<ol>
<li>
<p>把aop的schema引入</p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
</code></pre>
</li>
<li>
<p>创建一个切面类，并且以bean的方式配置到IOC容器中</p>
<pre><code class="language-java">package com.lanou3g.spring;
public class MyAspect {

    public void wakeup() {
        System.out.println(&quot;[前置通知]我刚学习SpringAOP睡着了，刚才谁打了我一下？&quot;);
    }


    public void goToBed() {
        System.out.println(&quot;[后置通知]SpringAOP太难了，一不小心又睡着了&quot;);
    }


    public void afterRetuing(Object message) {
        System.out.println(&quot;[后置返回通知]方法执行已经return了，方法返回值是：&quot; + message);
    }

    public void afterThrowing(Throwable ex) {
        System.out.println(&quot;[后置异常通知]方法执行出现异常，异常原因：&quot; + ex.getMessage());
    }

    /**
     * 环绕通知
     * 可以接受一个ProceedingJoinPoint参数
     *      通过此参数可以获取到被切入方法的所有信息
     *      还可以通过此参数来决定是否调用目标方法
     */
    public void aroundAdvice(ProceedingJoinPoint joinPoint) {

        // 连接点参数可以获取到被切入方法的所有信息
        // 这里演示了如何获取被切入方法的名称
        String targetMethodName = joinPoint.getSignature().getName();
        System.out.println(&quot;[环绕通知]被切入的方法名：&quot; + targetMethodName);

        //
        System.out.println(&quot;[环绕通知]即将开始新的一天， 早起的鸟儿有虫吃！&quot;);
        try {
            joinPoint.proceed();
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        System.out.println(&quot;[环绕通知]这真是充实的一天， 早睡早起，方能养生！&quot;);
    }
}
</code></pre>
<pre><code class="language-xml">&lt;bean id=&quot;myAspect&quot; class=&quot;com.lanou3g.spring.MyAspect&quot; /&gt;
</code></pre>
</li>
<li>
<p>使用<a href="aop:config">aop:config</a>标签配置aop（将切面、切入点、通知结合到一起）</p>
<ol>
<li>定义切入点表达式</li>
<li><a href="aop:aspect">aop:aspect</a>
<ol>
<li>引用外部定义的切面bean</li>
<li>配置通知，引用切入点表达式</li>
</ol>
</li>
</ol>
<pre><code class="language-xml">&lt;aop:config&gt;
    &lt;!-- 切入点表示匹配com.lanou3g.spring包下的所有类中所有以oneDay开头的方法，方法的参数、返回值不限 --&gt;
	&lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(* com.lanou3g.spring..*.oneDay*(..))&quot; /&gt;
    &lt;aop:aspect ref=&quot;myAspect&quot;&gt;
    	&lt;!-- 无论是否出现异常，只要被切入的方法开始运行，都会触发此通知 --&gt;
            &lt;aop:before method=&quot;wakeup&quot; pointcut-ref=&quot;beforeOneDay&quot; /&gt;
            &lt;!-- 无论是否出现异常，只要被切入的方法运行结束，都会触发此通知 --&gt;
            &lt;aop:after method=&quot;goToBed&quot; pointcut-ref=&quot;beforeOneDay&quot; /&gt;
            &lt;!--
            可以最大限度的对被切入方法附加功能，在方法执行前、后都可以通知（无论是否出现异常）
            ，还可以获取到被切入方法的所有信息，包括是否调用被切入的方法
            --&gt;
            &lt;aop:around method=&quot;aroundAdvice&quot; pointcut-ref=&quot;beforeOneDay&quot; /&gt;
            &lt;!-- 被切入的方法正常返回值以后，会触发此通知 --&gt;
            &lt;aop:after-returning method=&quot;afterRetuing&quot; pointcut-ref=&quot;beforeOneDay&quot; returning=&quot;message&quot; /&gt;
            &lt;!-- 被切入的方法抛出异常以后，会触发此通知，并且不会触发after-returning --&gt;
            &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;beforeOneDay&quot; throwing=&quot;ex&quot; /&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>
</li>
</ol>
<h3 id="基于注解方式使用">基于注解方式使用</h3>
<ol>
<li>
<p>开启AOP注解支持</p>
<p>方式一：注解的方式</p>
<pre><code class="language-xml">@Configuration
@EnableAspectJAutoProxy
public class AppConfig {

}
</code></pre>
<p>方式二：xml中开启</p>
<pre><code class="language-xml">&lt;aop:aspectj-autoproxy/&gt;
</code></pre>
<ol start="2">
<li>定义切面类</li>
</ol>
<pre><code class="language-java">/**
 * 该切面用来插入起床的逻辑
 */
@Aspect
@Component  //@Aspect注解没有将bean交给ioc容器管理的功能
public class MyAspect {

    @Before(&quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;)
    public void wakeup() {
        System.out.println(&quot;[前置通知]我刚学习SpringAOP睡着了，刚才谁打了我一下？&quot;);
    }

    @After(&quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;)
    public void goToBed() {
        System.out.println(&quot;[后置通知]SpringAOP太难了，一不小心又睡着了&quot;);
    }

    @AfterReturning(value = &quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;, returning = &quot;message&quot;)
    public void afterRetuing(Object message) {
        System.out.println(&quot;[后置返回通知]方法执行已经return了，方法返回值是：&quot; + message);
    }

    @AfterThrowing(value = &quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;, throwing = &quot;ex&quot;)
    public void afterThrowing(Throwable ex) {
        System.out.println(&quot;[后置异常通知]方法执行出现异常，异常原因：&quot; + ex.getMessage());
    }

    /**
     * 环绕通知
     * 可以接受一个ProceedingJoinPoint参数
     *      通过此参数可以获取到被切入方法的所有信息
     *      还可以通过此参数来决定是否调用目标方法
     */
//    @Around(&quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;)
    public Object aroundAdvice(ProceedingJoinPoint joinPoint) {

        // 连接点参数可以获取到被切入方法的所有信息
        // 这里演示了如何获取被切入方法的名称
        String targetMethodName = joinPoint.getSignature().getName();
        System.out.println(&quot;[环绕通知]被切入的方法名：&quot; + targetMethodName);

        //
        System.out.println(&quot;[环绕通知]即将开始新的一天， 早起的鸟儿有虫吃！&quot;);
        Object ret = null;
        try {
            ret = joinPoint.proceed();
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        System.out.println(&quot;[环绕通知]这真是充实的一天， 早睡早起，方能养生！&quot;);
        return ret;
    }
}
</code></pre>
<blockquote>
<p>注意：@Aspect注解没有将bean交给ioc容器管理的功能，我们需要额外添加一个@Component注解</p>
</blockquote>
<ol start="3">
<li>定义切入点</li>
</ol>
<p>官方建议我们将所有的切入点统一定义到一个地方管理，在配置通知时通过引入的方式来使用。方便后期维护（一处修改，处处生效）</p>
<pre><code class="language-java">@Component
public class MyPointcut {
    // 通过@Pointcut注解定义一个切入点
    @Pointcut(&quot;execution(* oneDay(..))&quot;)
    public void allOneDayMehtod() {}
}
</code></pre>
<ol start="4">
<li>在切面类中添加要切入的代码</li>
</ol>
<blockquote>
<p>参见定义切面部分</p>
</blockquote>
<ol start="5">
<li>在切入的代码方法上添加通知的注解</li>
</ol>
<blockquote>
<p>参见定义切面部分</p>
</blockquote>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA常见异常状态码]]></title>
        <id>https://klein-moretti.github.io/post/java-chang-jian-yi-chang-zhuang-tai-ma</id>
        <link href="https://klein-moretti.github.io/post/java-chang-jian-yi-chang-zhuang-tai-ma">
        </link>
        <updated>2018-11-26T11:34:21.000Z</updated>
        <content type="html"><![CDATA[<p>4xx（请求错误）<br>
这些状态代码表示请求可能出错，妨碍了服务器的处理。</p>
<p>代码 说明<br>
==400 ==（错误请求） 服务器不理解请求的语法。<br>
401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>
403 （禁止） 服务器拒绝请求。<br>
404 （未找到） 服务器找不到请求的网页。<br>
405 （方法禁用） 禁用请求中指定的方法。<br>
406 （不接受） 无法使用请求的内容特性响应请求的网页。<br>
407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。<br>
408 （请求超时） 服务器等候请求时发生超时。<br>
409 （冲突） 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。<br>
410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。<br>
411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。<br>
412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。<br>
413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。<br>
414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。<br>
415 （不支持的媒体类型） 请求的格式不受请求页面的支持。<br>
416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。<br>
417 （未满足期望值） 服务器未满足&quot;期望&quot;请求标头字段的要求。</p>
<p>5xx（服务器错误）<br>
这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p>
<p>代码 说明<br>
500 （服务器内部错误） 服务器遇到错误，无法完成请求。<br>
501 （尚未实施） 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。<br>
502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。<br>
503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。<br>
504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>
505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux常用命令]]></title>
        <id>https://klein-moretti.github.io/post/linux-chang-yong-ming-ling</id>
        <link href="https://klein-moretti.github.io/post/linux-chang-yong-ming-ling">
        </link>
        <updated>2018-10-12T08:28:43.000Z</updated>
        <content type="html"><![CDATA[<p>目录结构：<br>
https://www.runoob.com/linux/linux-system-contents.html</p>
<ol>
<li>在虚拟机中安装Centos操作系统<br>
使用VirtualBox虚拟机工具安装centos6操作系统</li>
</ol>
<p>**1.1 Linux **SSH操作终端<br>
使用SecureCRT工具通过ssh服务远程连接到linux，通过命令行操作</p>
<p>1.2. Linux常用命令<br>
目录相关命令：<br>
ls: 查看当前目录文件</p>
<p>ll:查看所有以及</p>
<p>cd: 切换工作目录 如: cd ~ （进入当前用户home目录）</p>
<p>pwd: 显示当前工作目录</p>
<p>mkdir: 新建目录</p>
<p>mkdir -p /././. :创建多级目录</p>
<p>cd … :跳出到根目录（到上一级目录 ）</p>
<p>ls-命令参数 :</p>
<p>-a 显示所有文件及目录 (ls内定将文件名或目录名称开头为&quot;.&quot;的视为隐藏档，不会列出)<br>
-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出<br>
-r 将文件以相反次序显示(原定依英文字母次序)<br>
-t 将文件依建立时间之先后次序列出<br>
-A 同 -a ，但不列出 “.” (目前目录) 及 “…” (父目录)<br>
-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/”<br>
-R 若目录下有文件，则以下之文件亦皆依序列出<br>
文件操作相关：<br>
cat: 查看文件内容</p>
<p>tail -fn 100 /etc/passwd （查看文件最后100行， 自动刷新，非常适合看日志）</p>
<p>rm: 删除</p>
<p>mv: 移动文件 (如果还移动到当前目录，就是重命名)</p>
<p>touch: 创建一个空文件</p>
<p>sz [文件名] ：下载Linux上的文件到本地系统</p>
<p>使用指令&quot;cp&quot;将当前目录&quot;test/&quot;下的所有文件复制到新目录&quot;newtest&quot;下，输入如下命令：</p>
<p>$ cp –r test/ newtest<br>
1<br>
**我们知道cp是复制，mv就是剪切，在windows下的叫法，在linux下二者还有一个区别，就是生成的文件的权限不一定相同。</p>
<p>**mv只是移动了文件，文件的一切都没有改变，而cp是在目标文件夹中创建了新的文件。</p>
<p>VIM 文本编辑相关：<br>
vim: linux上的一个强大的文本编辑器</p>
<p>保存并退出： :wq(命令模式下)、 ZZ（命令模式下）</p>
<p>不保存退出：:q! (命令模式下)</p>
<p>从命令模式切换到编辑模式： a、i、o</p>
<p>跳到文件头： gg</p>
<p>跳到文件尾：GG</p>
<p>进程相关命令：<br>
查看当前系统中运行了哪些进程：ps aux | grep vsftp (查看当前有没有运行ftp进程)</p>
<p>杀进程： kill -9 [进程号]</p>
<p>Centos安装包管理器Yum 命令：<br>
查看已安装的程序：sudo yum list installed | grep vsftp (查看是否安装了vsftp软件)</p>
<p>卸载已安装程序： sudo yum remove vsftpd.i686</p>
<p>安装程序： sudo yum install vsftpd</p>
<p>Centos防火墙命令相关:<br>
查看防火墙状态：service iptables status</p>
<p>关闭防火墙：service iptables stop</p>
<p>开启防火墙：service iptables start</p>
<p>服务开机自启动：<br>
chkconfig vsftpd on (设置vsftpd服务开机自启动)</p>
<p>关机服务开机自启：<br>
chkconfig iptables off (设置防火墙服务不开机自启)</p>
<p>关机：sudo halt –p</p>
<p>重启: sudo reboot</p>
<p>用户相关：<br>
useradd user1——创建用户user1</p>
<p>使用 passwd 命令为新建用户设置密码：password user1</p>
<p>命令 usermod 修改用户账户：usermod –l u1 user1 改名字</p>
<p>usermod –g users user1 ：加入用户组</p>
<p>su user :查询进入用户</p>
<p>sudo password user：重置这个用户的密码</p>
<p>删除用户：userdel user2</p>
<p>删除用户 user3，同时删除他的工作目录：userdel –r user3</p>
<p>d命令查看一个用户的UID和GID, 例：查看user4的id：：id user4<br>
finger命令 ——可以查看用户的主目录、启动shell、用户名、地址、电话等信息</p>
<p>命令 groupadd创建用户组：：groupadd –g 888 users ：：创建一个组users，其GID为888</p>
<p>两种方式，我们以kill用户user为例:</p>
<p>pkill方式<br>
pkill -u user</p>
<p>killall方式<br>
killall -u user</p>
<p>其他：<br>
sudo make &amp;&amp; make install：同时执行多个简单的命令</p>
<p>./configure\：后面的\是转义，代表不换行太长了继续编辑</p>
<p>ps aux | grep nginx ：查看是否启动（也是查看有无进程）</p>
<p>wget url ：直接根据url链接下载</p>
<p>rz -be:上传本地的文件到Linux</p>
<p>tar -zxf 。。。。：解压tar包</p>
<p>语法：unzip ［选项］ 压缩文件名.zip</p>
<p>sudo ./nginx -s reload :热加载（修改了配置文件后不重启，热加载让其生效！）</p>
<p>查看虚拟机IP：：ip address</p>
<p>ll -a | grep sudoers ：查看文件权限</p>
<p>chmod 664 sudoers：添加文件权限</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringMVC总结]]></title>
        <id>https://klein-moretti.github.io/post/springmvc-zong-jie</id>
        <link href="https://klein-moretti.github.io/post/springmvc-zong-jie">
        </link>
        <updated>2018-07-31T12:02:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="springmvc">SpringMVC</h1>
<h2 id="mvc设计模式">MVC设计模式</h2>
<p>其实在之前JavaWeb阶段我们已经接触到了MVC模式。</p>
<p>MVC里面的M指的的Model（通常包含bean、dao(mapper)、service）；V指的是View，视图层，视图层主要的技术（JSP、HTML、FreeMaker、Themeleaf）；C指的是Controller，控制层。控制层不负责具体数据、逻辑的处理和运算，它只负责将Model层的结果返回给对应的视图层去展示。</p>
<p>在JavaWeb阶段， Controller层指的就是Servlet； View层指的就是JSP或者HTML;  Model层指的就是bean、dao、service。</p>
<p>在J2EE阶段，Controller层指的就是SpringMVC、Structs1\2；  View层不变还是主流的页面展示技术; Model层包括bean、mybatis、service。</p>
<h2 id="springmvc的优势">SpringMVC的优势</h2>
<ul>
<li>SpringMVC是一款很轻量级的框架，要使用它的组件我们往往只需要定义一些最简单的Java类，然后添加某些注解就可以了</li>
<li>SpringMVC的参数注入只直接注入到方法中，可以很好的做到不同请求间数据的隔离，而Struts2是注入到类实例变量上，不同的请求可能会覆盖参数。</li>
<li>SpringMVC可以很轻易的和Spring整合，而Struts需要做比较复杂的配置。</li>
</ul>
<h2 id="springmvc简单使用">SpringMVC简单使用</h2>
<ol>
<li>
<p>添加依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>在web.xml中配置DispatcherServlet</p>
<pre><code class="language-xml">&lt;servlet&gt;
    &lt;servlet-name&gt;aa&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!-- 指定SpringMVC 配置文件位置，DispatcherServlet初始化时会初始化Spring上下文（WebApplicationContext） --&gt;
    &lt;!-- 默认配置文件寻找位置：/WEB-INF/{servlet-name}-servlet.xml，如果名字符合默认寻找规则，可以不指定配置文件路径 --&gt;
    &lt;!--&lt;init-param&gt;
      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
      &lt;param-value&gt;/WEB-INF/aa-servlet.xml&lt;/param-value&gt;
    &lt;/init-param&gt;--&gt;
    &lt;!-- 配置容器启动时初始化DispatcherServlet --&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;aa&lt;/servlet-name&gt;
    &lt;!-- 映射路径配置成/，代表当前Servlet是一个默认Servlet，就是当其他Servlet都无法处理请求时，由默认Servlet出马 --&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;!--    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;--&gt;
  &lt;/servlet-mapping&gt;
</code></pre>
</li>
<li>
<p>配置SpringMVC  dispatcher-servlet.xml</p>
<p>SpringMVC大部分组件都有默认配置，我们一般简单应用只需要指定视图解析器就行了</p>
<p>dispatcher-servlet.xml</p>
<pre><code class="language-xml">&lt;!-- 配置视图解析器，用于将Handler方法中返回的视图名解析成真正可展示的页面 --&gt;
&lt;mvc:view-resolvers&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/&quot; /&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;
&lt;/mvc:view-resolvers&gt;
</code></pre>
</li>
<li>
<p>定义Controller</p>
<p>新建一个普通类，然后添加<code>@Controller</code>注解，就可以了</p>
</li>
<li>
<p>定义请求处理方法(Handler)</p>
<p>在Controller类中定义一个普通的方法，添加<code>@RequestMapping</code>注解就可以了</p>
</li>
</ol>
<h2 id="springmvc主要组件">SpringMVC主要组件</h2>
<h3 id="rootapplicationcontext和servletapplicationcontext">RootApplicationContext和ServletApplicationContext</h3>
<figure data-type="image" tabindex="1"><img src="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/images/mvc-context-hierarchy.png" alt="父子上下文概念"></figure>
<h4 id="两个applicationcontext的联系和区别">两个ApplicationContext的联系和区别</h4>
<h3 id="视图解析器">视图解析器</h3>
<p>视图解析器的作用是将请求处理方法中的返回值解析成一个真正可以渲染的页面。</p>
<h4 id="常用的视图解析器">常用的视图解析器</h4>
<ul>
<li>
<p>InternalResourceViewResolver</p>
<p>内部资源解析器： 用于将返回值对应到项目路径下的某个可显示的页面。比如方法返回值是index字符串，那么<code>InternalResourceViewResolver</code>解析器会在index前加上指定的前缀，在index后加上指定的后缀来拼接成指向某个视图的路径。</p>
<pre><code class="language-xml">&lt;!-- 配置视图解析器，用于将Handler方法中返回的视图名解析成真正可展示的页面 --&gt;
&lt;mvc:view-resolvers&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/&quot; /&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;
&lt;/mvc:view-resolvers&gt;
</code></pre>
</li>
</ul>
<h3 id="参数传递">参数传递</h3>
<h4 id="页面参数传递到controller">页面参数传递到Controller</h4>
<h5 id="requestparam">@RequestParam</h5>
<p>获取请求参数，包括通过GET请求中的查询参数、POST请求中的参数等</p>
<pre><code class="language-java">@RequestMapping(&quot;/hello&quot;)
public String toHelloPage(@RequestParam String message, Model model) {
	model.addAttribute(&quot;msg&quot;, message);
	return &quot;hello_springmvc&quot;;
}


// 当方法参数名和请求参数不一样时，可以使用注解的参数对应起来
@RequestMapping(&quot;/hello&quot;)
public String toHelloPage(@RequestParam(&quot;message&quot;) String msg, Model model) {
	model.addAttribute(&quot;msg&quot;, message);
	return &quot;hello_springmvc&quot;;
}
</code></pre>
<blockquote>
<p>访问: http://localhost:8080/hello?message=zhangsan 时，message参数会自动注入到方法的message参数中。</p>
</blockquote>
<h5 id="requestheader">@RequestHeader</h5>
<p>获取请求头中的参数，如浏览器默认自带的userAgent就是请求头参数</p>
<pre><code class="language-java">@RequestMapping(&quot;/hello&quot;)
public String toHelloPage(@RequestHeader String userAgent, Model model) {
	model.addAttribute(&quot;msg&quot;, userAgent);
	return &quot;hello_springmvc&quot;;
}


// 当方法参数名和请求头参数不一样时，可以使用注解的参数对应起来
@RequestMapping(&quot;/hello&quot;)
public String toHelloPage(@RequestHeader(&quot;userAgent&quot;) String ua, Model model) {
	model.addAttribute(&quot;msg&quot;, ua);
	return &quot;hello_springmvc&quot;;
}
</code></pre>
<blockquote>
<p>会自动将请求头中的userAgent参数注入到方法中</p>
</blockquote>
<h5 id="pathvariable">@PathVariable</h5>
<p>获取请求地址中的参数，注入到方法参数中</p>
<pre><code class="language-java">@RequestMapping(&quot;/hello/{sname}&quot;)
public String toHelloPage(@PathVariable String sname, Model model) {
	model.addAttribute(&quot;msg&quot;, sname);
	return &quot;hello_springmvc&quot;;
}


// 当方法参数名和请求地址中参数不一样时，可以使用注解的参数对应起来
@RequestMapping(&quot;/hello/{sname}&quot;)
public String toHelloPage(@PathVariable(&quot;sname&quot;) String sn, Model model) {
	model.addAttribute(&quot;msg&quot;, sn);
	return &quot;hello_springmvc&quot;;
}
</code></pre>
<blockquote>
<p>访问：http://localhost:8080/hello/zhangsan  会自动将zhangsan注入到方法的参数中</p>
</blockquote>
<h5 id="requestattribute">@RequestAttribute</h5>
<p>jsp中</p>
<pre><code class="language-jsp">&lt;%
        request.setAttribute(&quot;sname&quot;, &quot;虞姬req&quot;);
        request.getRequestDispatcher(&quot;/param/req_scope&quot;).forward(request, response);
%&gt;
</code></pre>
<p>Controller中</p>
<pre><code class="language-java">/**
  * 请求作用域中的参数的传递
  * @return
  */
@RequestMapping(&quot;/req_scope&quot;)
public String requestScopeParamShow(@RequestAttribute String sname, Model model) {
    model.addAttribute(&quot;sname&quot;, sname);
    model.addAttribute(&quot;type&quot;, &quot;请求作用域参数&quot;);
    return &quot;param_show&quot;;
}
</code></pre>
<blockquote>
<p>获取请求作用域中的参数</p>
</blockquote>
<h5 id="sessionattribute">@SessionAttribute</h5>
<blockquote>
<p>获取Session作用域中的参数，用法和上面请求作用域中使用类似</p>
</blockquote>
<h5 id="cookievalue">@CookieValue</h5>
<p>jsp中代码</p>
<pre><code class="language-jsp">cookie参数传递：&lt;br /&gt;
&lt;%
response.addCookie(new Cookie(&quot;sname&quot;, &quot;yuji_cookie&quot;));
%&gt;
&lt;a href=&quot;/param/cookie&quot;&gt;发起请求&lt;/a&gt;
</code></pre>
<p>Controller中</p>
<pre><code class="language-java">/**
  * Cookie中的参数的传递
  * @return
  */
@RequestMapping(&quot;/cookie&quot;)
public String cookieParamShow(@CookieValue String sname, Model model) {
    model.addAttribute(&quot;sname&quot;, sname);
    model.addAttribute(&quot;type&quot;, &quot;cookie参数&quot;);
    return &quot;param_show&quot;;
}
</code></pre>
<blockquote>
<p>获取Cookie中的指定数据</p>
</blockquote>
<blockquote>
<p>上面这几个注解都是用于在方法的参数上标注，用于获取不同种类的参数</p>
</blockquote>
<h4 id="controller中的数据传递到页面">Controller中的数据传递到页面</h4>
<h5 id="model">Model</h5>
<p>handler方法定义：</p>
<pre><code class="language-java">@RequestMapping(&quot;/show_msg&quot;)
public String showMessage(Model model) {
    model.addAttribute(&quot;msg&quot;, &quot;我是通过model传过来的参数&quot;);
    return &quot;message_page&quot;;
}
</code></pre>
<p>message_page.jsp</p>
<pre><code class="language-jsp">&lt;h1&gt;
    获取后台参数： ${msg}
&lt;/h1&gt;
</code></pre>
<h5 id="modelandview">ModelAndView</h5>
<pre><code class="language-java">/**
 * ModelAndView其实是将数据Model和视图View做了一个封装，底层实现原理一样
 */
@RequestMapping(&quot;/show_msg&quot;)
public ModelAndView showMessage(ModelAndView mv) {
    mv.addObject(&quot;msg&quot;, &quot;我是通过model传过来的参数&quot;);
    mv.setViewName(&quot;message_page&quot;);
    return mv;
}
</code></pre>
<blockquote>
<p>Model和ModelAndView传递的参数本质上也是用请求作用域来实现的，所以仅对请求转发有效。</p>
</blockquote>
<h3 id="视图控制器">视图控制器</h3>
<p>用于通过配置的方式简化我们项目中不含业务逻辑的页面跳转，省去了我们写一个空方法的步骤。</p>
<h4 id="视图控制器的作用和用法">视图控制器的作用和用法</h4>
<p>试想一下，如果我们的工程中有这样的一个需求，比如当用户点了某个链接和按钮的时候，我们需要做一个页面跳转，这个跳转的目标可能是一个公开目录的页面也可能是私有目录（/WEB-INF/下）的页面、还可能是跳转到后台Controller的某个方法中，我们如何实现？</p>
<p>示例：比如我们想将登陆页设置为一个项目默认欢迎页面</p>
<p>方案一：在Controller中添加一个拦截/的handler方法</p>
<pre><code class="language-java">@RequestMapping(&quot;/&quot;)
public String toWelcomePage() {
    return &quot;login&quot;;
}
</code></pre>
<p>方法二：使用视图控制器</p>
<p>在dispatcher-servlet.xml（SpringMVC配置文件）配置中添加</p>
<pre><code class="language-xml">&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;login&quot; /&gt;
</code></pre>
<ul>
<li>path: 指定要匹配的访问路径</li>
<li>view-name: 返回的逻辑视图名</li>
<li>status-code: 设置响应状态码。(注：不能通过只设置状态码，不设置view-name实现只返回code，没有页面的处理)</li>
</ul>
<blockquote>
<p>view-name不仅可以是逻辑视图名，还可以添加forward、redirect前缀，通过转发或重定向的方式跳转到一个具体的路径，如：&lt;mvc:view-controller path=&quot;/&quot; view-anme=&quot;forward:/WEB-INF/login.jsp&quot; /&gt;</p>
</blockquote>
<!-- SpringMVC 第二天 -->
<h3 id="设置web项目的默认欢迎页">设置Web项目的默认欢迎页</h3>
<ul>
<li>
<p>在web.xml中使用<welcome-file-list>标签指定</p>
</li>
<li>
<p>使用上面提到的视图控制器</p>
<pre><code class="language-xml">&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;逻辑视图名&quot; /&gt;
&lt;!-- 当工程中存在Tomcat默认欢迎页同名文件时此种方式可能失效，比如index.html、index.jsp、index.htm --&gt;
</code></pre>
</li>
</ul>
<h3 id="静态资源处理">静态资源处理</h3>
<pre><code class="language-xml">&lt;!-- 针对静态资源的处理 --&gt;
    &lt;!-- http://localhost:8080/static/css/index.css --&gt;
&lt;mvc:resources mapping=&quot;/static/**&quot; location=&quot;/static/&quot; /&gt;
</code></pre>
<h3 id="重定向和转发">重定向和转发</h3>
<h4 id="在servlet实现重定向和转发">在Servlet实现重定向和转发：</h4>
<p>重定向：response.sendRedirect(&quot;xxx.jsp&quot;);</p>
<p>转发： request.getRequestDispatcher(&quot;xxx.jsp&quot;).forward(request, response);</p>
<h4 id="在springmvc中">在SpringMVC中</h4>
<h5 id="请求转发有三种方式">请求转发有三种方式</h5>
<ul>
<li>在Handler方法中直接返回逻辑视图名称</li>
<li>在Handler方法中返回&quot;forward:路径&quot;</li>
<li>在Handler方法中返回InternalResourceView对象</li>
</ul>
<blockquote>
<p>其中第二种和第三种作用一样， 都是将路径用请求转发的方式跳转，返回的路径时不经过视图解析器处理的；而第一种虽然也是通过请求转发方式跳转，但是返回值会作为逻辑视图名称，经过视图解析器处理后，才渲染。</p>
</blockquote>
<h5 id="重定向有两种方式">重定向有两种方式</h5>
<ul>
<li>在Handler方法中返回&quot;redirect:路径&quot;</li>
<li>在Handler方法中返回RedirectView对象</li>
</ul>
<blockquote>
<p>这两种方法效果一样。 注意使用重定向的方式跳转页面，Model中的数据就无法带到页面了（因为Model底层也是用请求作用域来传递参数的）。</p>
</blockquote>
<h3 id="restfull服务接口开发">RESTFull服务接口开发</h3>
<p>SpringMVC给我们提供了一系列的注解用于支持RESTFull风格的服务开发</p>
<h4 id="常用restfull注解">常用RESTFull注解</h4>
<ul>
<li>
<p><code>@RestController</code></p>
<p>该注解本身是一个组合注解，由<code>@Controller</code>和<code>@ResponseBody</code>两个注解组成，所以拥有这两个注解的作用。 在类上声明后，该类会变成一个Controller类，同时，方法的返回值会作为响应体经过消息转换器直接响应给客户端，而不会将其作为视图渲染。</p>
<pre><code class="language-java">@RestController // 这个注解其实是组合了下面两个注解的作用
//@Controller
//@ResponseBody
public class UserRestController {

}
</code></pre>
</li>
<li>
<p><code>@GetMapping</code> :</p>
<p>作用： 申明当前handler方法只匹配GET请求</p>
<p>使用示例</p>
<pre><code class="language-java">@GetMapping(&quot;/{id}&quot;)
public User getUserById(@PathVariable Integer id) {
    return userService.findById(id);
}
</code></pre>
</li>
<li>
<p><code>@PostMapping</code>: 申明当前handler方法只匹配POST请求</p>
</li>
<li>
<p><code>@DeleteMapping</code>: 申明当前handler方法只匹配DELETE请求</p>
</li>
<li>
<p><code>@PutMapping</code>: 申明当前handler方法只匹配PUT请求</p>
</li>
</ul>
<blockquote>
<p>上面四个注解分别对应HTTP的一种请求方法，使用方法类似。</p>
</blockquote>
<p>上面四个注解其实是一种快捷注解， 等效于使用下面代码：</p>
<pre><code class="language-java">@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.GET)
@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.POST)
@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.PUT)
@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.DELETE)
</code></pre>
<ul>
<li>@PathVariable: 获取请求地址中的变量，注入到方法参数中</li>
</ul>
<h4 id="返回json格式的数据-消息转换器">返回JSON格式的数据 —— 消息转换器</h4>
<h5 id="消息转换器是什么">消息转换器是什么</h5>
<p>之前我们在写普通Controller时，handler方法的返回值要是就是一个String（逻辑视图名），要么就是一个ModelAndView、View对象。</p>
<p>而我们使用了RestController之后，方法的返回值已经不会被作为视图去渲染了，这时候我们的方法其实可以返回任意类型的数据。这些数据会直接通过响应体以流的方式返回给客户端。</p>
<p>我们知道Java中的对象是不能直接用流的方式读取的，需要序列化。比如我们的handler方法返回了一个User类型，SpringMVC就不知道如果将这个类型返回给客户端了。这时就需要我们通过配置消息转换器来完成这种类型对象的返回处理。 而在RESTFull服务中，对象绝大部分传递方式就是通过JSON格式。</p>
<h5 id="如何配置一个转换json格式的消息转换器">如何配置一个转换JSON格式的消息转换器</h5>
<ul>
<li>
<p>使用SpringMVC默认的Jackson库</p>
<ol>
<li>
<p>引入依赖</p>
<pre><code class="language-xml">&lt;!-- jackson依赖，用于将handler方法返回的对象直接转换成JSON数据 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.9.7&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>开启mvc注解支持</p>
<pre><code class="language-xml">&lt;mvc:annotation-driven /&gt;
</code></pre>
</li>
<li>
<p>定义Controller类</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/user&quot;)
public class UserRestController {
    
    @GetMapping(&quot;/{id}&quot;)
    public User getUserById(Integer id) {
        return userService.findById(id);
    }
    
}
</code></pre>
</li>
</ol>
<blockquote>
<p>Jackson是SpringMVC默认的JSON格式消息转换器， 所以在不配置额外转json参数时，我们可以直接只引入jackson依赖，再开启mvc直接支持就可以了。而第三方的转换库如FastJSON就必须显示配置MessageConverter</p>
</blockquote>
</li>
<li>
<p>使用阿里巴巴的FastJSON库</p>
<ol>
<li>
<p>引入依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
     &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
     &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
     &lt;version&gt;1.2.57&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>配置MessageConverter</p>
<pre><code class="language-xml">&lt;mvc:annotation-driven&gt;
    &lt;mvc:message-converters&gt;
        &lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;&gt;
            &lt;property name=&quot;defaultCharset&quot; value=&quot;UTF-8&quot; /&gt;
            &lt;property name=&quot;fastJsonConfig&quot;&gt;
                &lt;!-- 设置转换JSON的参数 --&gt;
                &lt;bean class=&quot;com.alibaba.fastjson.support.config.FastJsonConfig&quot;&gt;
                    &lt;property name=&quot;dateFormat&quot; value=&quot;yyyy-MM-dd HH:mm:ss&quot; /&gt;
                &lt;/bean&gt;
            &lt;/property&gt;
            &lt;property name=&quot;supportedMediaTypes&quot;&gt;
            &lt;!-- 指定转换完JSON后返回的响应头和编码，添加text/html是为了处理在IE下application/json会弹出下载框问题 --&gt;
                &lt;list&gt;
                    &lt;!--&lt;value&gt;text/html;charset=UTF-8&lt;/value&gt;--&gt;                
                    &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt;
                &lt;/list&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/mvc:message-converters&gt;
&lt;/mvc:annotation-driven&gt;
</code></pre>
</li>
<li>
<p>定义Controller类</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/user&quot;)
public class UserRestController {
    
    @GetMapping(&quot;/{id}&quot;)
    public User getUserById(Integer id) {
        return userService.findById(id);
    }
    
}
</code></pre>
</li>
</ol>
</li>
</ul>
<h4 id="通过网页模拟restfull请求">通过网页模拟RESTFull请求</h4>
<p>通过SpringMVC给我们提供的一个过滤器，我们可以用表单模拟各种RESTFull的请求，使用方法如下：</p>
<ol>
<li>
<p>在web.xml中添加过滤器</p>
<pre><code class="language-xml">&lt;filter&gt;
    &lt;filter-name&gt;httpMethodFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;httpMethodFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
</li>
<li>
<p>在表单中添加name为_method的hidden域，并将表单的method设置为post</p>
<pre><code class="language-html">&lt;!-- 使用表单模拟发起一个DELETE请求，删除user表中id为57的数据 --&gt;
&lt;form action=&quot;/user/57&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;delete&quot; /&gt;
    &lt;input type=&quot;number&quot; name=&quot;id&quot; /&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;
    &lt;input type=&quot;submit&quot; /&gt;
&lt;/form&gt;
</code></pre>
</li>
</ol>
<blockquote>
<p>由于RESTFull请求通常发生在服务于服务之间的调用，所以有些请求用浏览器不太好模拟，建议使用专业的网络测试工具postman来进行测试。</p>
</blockquote>
<h4 id="resttemplate工具类">RestTemplate工具类</h4>
<p>SpringMVC帮我们封装的一个Rest请求工具，可以使用一个URI地址发起网络请求，并且将结果封装成一个指定的对象。</p>
<h3 id="处理请求乱码">处理请求乱码</h3>
<p>SpringMVC给我们提供了一个专门用来解决post请求乱码的过滤器，我们只需将其配置到web.xml中，就可以避免post请求乱码，免去了我们自己写过滤器的麻烦</p>
<p>在web.xml中</p>
<pre><code class="language-xml">&lt;!-- 解决POST请求乱码 --&gt;
&lt;filter&gt;
    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;forceEncoding&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<blockquote>
<p>注意： 如果项目中配置了多个过滤器，建议将此过滤器放到所有过滤器的最上面。</p>
</blockquote>
<h3 id="在springmvc方法中支持的参数">在SpringMVC方法中支持的参数</h3>
<p>SpringMVC的handler方法中支持诸如很多特殊类型的参数，常用的有</p>
<h5 id="注入原生servlet对象">注入原生Servlet对象</h5>
<ul>
<li>javax.servlet.ServletRequest</li>
<li>javax.servlet.ServletResponse</li>
<li>javax.serlvet.http.HttpSession</li>
</ul>
<h5 id="以流的方式读取请求体-以流的方式响应到客户端">以流的方式读取请求体、以流的方式响应到客户端</h5>
<ul>
<li><s>java.io.InputStream、java.io.Reader</s></li>
<li><s>java.io.OutputStream、java.io.Writer</s></li>
</ul>
<h5 id="读取请求体和请求头数据">读取请求体和请求头数据</h5>
<ul>
<li>HttpEntity</li>
</ul>
<h5 id="向页面传参">向页面传参</h5>
<ul>
<li>java.util.Map，org.springframework.ui.Model、org.springframework.ui.ModelMap</li>
</ul>
<!-- SpringMVC 第三天 -->
<h3 id="文件上传">文件上传</h3>
<h4 id="说明">说明</h4>
<p>在Java中，主流的文件上传方式有两种，分别是通用文件上传(commons-fileupload)和Servlet3.0方式的文件上传。SpringMVC分别对着两种方式都做了支持。</p>
<ul>
<li>CommonsMultipartResolver</li>
<li>StandardServletMultipartResolver</li>
</ul>
<blockquote>
<p>除此之外SpringMVC对文件上传的接口做了统一的封装，使用<code>MultipartFile</code>接口代替了通用上传中的<code>FileItem</code>和Servlet3.0中的<code>Part</code>，使得开发人员在业务代码中可以使用统一的接口处理，而不用管底层用的是哪种文件上传实现方式。</p>
</blockquote>
<h4 id="基于apache-fileupload通用文件上传包">基于Apache Fileupload通用文件上传包</h4>
<ol>
<li>
<p>添加依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
    &lt;version&gt;1.4&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-io&lt;/groupId&gt;
    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
    &lt;version&gt;2.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>在SpringMVC配置文件中添加MultipartResolver文件上传解析器</p>
<pre><code class="language-xml">&lt;!-- 配置基于apache fileupload的通用文件上传器（注意：id属性不可省略） --&gt;
&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
    &lt;!-- 指定文件上传编码 --&gt;
    &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot; /&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>在Controller中编写文件上传逻辑代码</p>
<pre><code class="language-java">@RequestMapping(&quot;/upload&quot;)
public String upload(@RequestParam(&quot;myFile&quot;) MultipartFile file, HttpServletRequest req, Model model) {
    try {
        // 使用SpringMVC给我们提供的工具类获取项目中upload文件夹在硬盘上的绝对路径
        String uploadPath = WebUtils.getRealPath(req.getServletContext(), &quot;/upload/&quot;);
        // 将上传的文件写到上传目录
        file.transferTo(new File(uploadPath+file.getOriginalFilename()));
    } catch (IOException e) {
        e.printStackTrace();
    }
}
</code></pre>
</li>
</ol>
<h4 id="基于servlet30标准api文件上传">基于Servlet3.0标准API文件上传</h4>
<ol>
<li>
<p>开启Servlet文件上传支持</p>
<p>web.xml</p>
<pre><code class="language-xml">&lt;servlet&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!-- 开启Servlet文件上传支持 --&gt;
    &lt;multipart-config /&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
</li>
<li>
<p>在SpringMVC中配置MultipartResolver</p>
<pre><code class="language-xml">&lt;!-- 配置基于Servlet3.0文件上传器（注意：id属性不可省略） --&gt;
&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.support.StandardServletMultipartResolver&quot; /&gt;
</code></pre>
</li>
<li>
<p>在Controller中编写文件上传逻辑代码</p>
<blockquote>
<p>实现方式同通用上传代码一样。</p>
</blockquote>
</li>
</ol>
<h4 id="文件名上传乱码问题">文件名上传乱码问题</h4>
<ul>
<li>
<p>使用通用上传方式的解决方法</p>
<p>在配置的CommonsMultipartResolver bean中注入属性</p>
<pre><code class="language-xml">&lt;!-- 配置基于apache fileupload的通用文件上传器（注意：id属性不可省略） --&gt;
&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
    &lt;!-- 指定文件上传编码 --&gt;
    &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot; /&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>使用Servlet3.0标准上传方式的解决方法</p>
<p>通过配置SpringMVC提供的编码过滤器解决</p>
<p>web.xml</p>
<pre><code class="language-xml">&lt;filter&gt;
    &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;forceEncoding&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<blockquote>
<p>本质上还是设置请求的编码 request.setCharacterEncoding(&quot;UTF-8&quot;);</p>
</blockquote>
</li>
</ul>
<h3 id="拦截器">拦截器</h3>
<h4 id="拦截器-vs-过滤器">拦截器 VS 过滤器</h4>
<p>过滤器是Servlet规范中提供的一项技术。不依赖于任何第三方框架。它的作用主要用来做两件事： 加工请求、过滤请求。</p>
<p>拦截器是SpringMVC自己封装的一项基于Handler拦截的结束。也就是说只有在SpringMVC框架里面才有拦截器的概念。拦截器拦截的对象是Handler。它的全称是 HandlerInterceptor。</p>
<p>加上拦截器以后，请求处理流程：  request -&gt; DispatcherServlet -&gt; HandlerMapping -&gt; HandlerExecutionChain(包含了目标handler和若干个拦截器) -&gt; HandlerAdapter -&gt; 循环调用HandlerExecutionChain对象中所有拦截器的prehandler方法 -&gt; 如果preHandler返回false，那么handler将不会被调用。反之，才会正常调用。</p>
<h4 id="如何使用拦截器">如何使用拦截器</h4>
<h5 id="定义拦截器类">定义拦截器类</h5>
<p>新建一个类实现HandlerInterceptor接口</p>
<pre><code class="language-java">/**
 * 定义拦截器步骤：
 *      1. 定义一个普通类，实现HandlerInterceptor接口
 *      2. 按需实现接口中的方法
 *      3. 在SpringMVC配置文件中通过&lt;mvc:interceptors&gt;&lt;/mvc:interceptors&gt;配置拦截器
 */
public class NotAllowedInterceptor implements HandlerInterceptor {

    /**
     * 此回调方法在执行Handler之前被调用
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println(&quot;进入NotAllowedInterceptor, 凡是我能拦截到的请求，一律不准通过!&quot;);
        return false;
    }

    /**
     * 此回调方法在执行Handler之后被调用
     * @param request
     * @param response
     * @param handler
     * @param modelAndView
     * @throws Exception
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {

    }

    /**
     * 此回调方法在DispatcherServlet最终响应之前被调用
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {

    }
}
</code></pre>
<h5 id="配置拦截器">配置拦截器</h5>
<h6 id="全局拦截器">全局拦截器</h6>
<pre><code class="language-xml">&lt;mvc:interceptors&gt;
    &lt;!-- 这种方式配置的拦截器会拦截所有请求 --&gt;
    &lt;bean class=&quot;com.lanou3g.springmvc.interceptor.NotAllowedInterceptor&quot; /&gt;
&lt;/mvc:interceptors&gt;
</code></pre>
<h6 id="拦截指定请求的拦截器">拦截指定请求的拦截器</h6>
<pre><code class="language-xml">&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;!-- 拦截的请求 --&gt;
        &lt;mvc:mapping path=&quot;/admin/**&quot; /&gt;
        &lt;!-- 不拦截的请求 --&gt;
        &lt;mvc:exclude-mapping path=&quot;/intercepor/**&quot;/&gt;
        &lt;!-- 配置我们定义的实现了HandlerInterceptor接口的类 --&gt;
        &lt;bean class=&quot;com.lanou3g.springmvc.interceptor.NotAllowedInterceptor&quot; /&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[三大框架整合]]></title>
        <id>https://klein-moretti.github.io/post/san-da-kuang-jia-zheng-he</id>
        <link href="https://klein-moretti.github.io/post/san-da-kuang-jia-zheng-he">
        </link>
        <updated>2018-05-13T14:55:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="ssm整合步骤">SSM整合步骤</h1>
<h2 id="spring和mybatis整合">Spring和Mybatis整合</h2>
<ol>
<li>
<p>加入Spring、mybatis的依赖</p>
<pre><code class="language-xml">&lt;!-- Spring相关依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- mybatis相关依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
    &lt;version&gt;3.4.6&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- Spring、Mybatis整合依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;version&gt;1.3.2&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- mysql驱动 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;5.1.47&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>在Spring bean配置文件中，配置整合的Bean</p>
<p>在类路径下新建applicationContext.xml文件，做如下配置：</p>
<ol>
<li>
<p>配置数据源</p>
<pre><code class="language-xml">&lt;context:property-placeholder location=&quot;classpath*:/jdbc.properties&quot; /&gt;
&lt;!-- 连接池 --&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;
    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;
    &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;
    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>配置SqlSessionFactoryBean</p>
<pre><code class="language-xml">&lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
    &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.lanou3g.ssm.bean&quot; /&gt;
    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:/mybatis/mappers/*.xml&quot; /&gt;
&lt;/bean&gt;
</code></pre>
</li>
</ol>
</li>
<li>
<p>编写mybatis的mapper映射文件、mapper接口、核心配置文件(可选)</p>
<blockquote>
<p>mapper映射文件和mapper接口可直接用mybatis逆向工程生成</p>
</blockquote>
</li>
<li>
<p>配置扫描包路径</p>
<pre><code class="language-xml">&lt;context:component-scan base-package=&quot;com.lanou3g.ssm.service&quot;  /&gt;
</code></pre>
</li>
<li>
<p>配置mapper接口扫描路径</p>
<pre><code class="language-xml">&lt;mybatis:scan base-package=&quot;com.lanou3g.ssm.mapper&quot; /&gt;
</code></pre>
<blockquote>
<p>作用是让mybatis去指定的包下找Mapper接口，生成实现类，注入到IOC容器中</p>
</blockquote>
</li>
</ol>
<h2 id="spring和springmvc">Spring和SpringMVC</h2>
<ol>
<li>
<p>添加SpringMVC依赖和Servlet、JSTL依赖</p>
<pre><code class="language-xml">&lt;!-- SpringMVC依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- Servlet api 依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
    &lt;version&gt;3.1.0&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;jstl&lt;/artifactId&gt;
    &lt;version&gt;1.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>配置SpringMVC</p>
<p>web.xml</p>
<pre><code class="language-xml">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee
                      http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot;&gt;

  &lt;!-- 配置root applicationContext --&gt;
  &lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;classpath*:application*.xml&lt;/param-value&gt;
  &lt;/context-param&gt;

  &lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
  &lt;/listener&gt;

  &lt;!-- 配置请求编码 --&gt;
  &lt;filter&gt;
    &lt;filter-name&gt;charchaterFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;encoding&lt;/param-name&gt;
      &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
  &lt;/filter&gt;
  &lt;filter-mapping&gt;
    &lt;filter-name&gt;charchaterFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;

  &lt;!-- 配置DispatcherServlet大总管 --&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;

&lt;/web-app&gt;
</code></pre>
<p>dispatcher-servlet.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!-- 配置扫描Controller的包路径 --&gt;
    &lt;context:component-scan base-package=&quot;com.lanou3g.ssm.web&quot; /&gt;

    &lt;!-- 配置视图解析器 --&gt;
    &lt;mvc:view-resolvers&gt;
        &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
            &lt;property name=&quot;prefix&quot; value=&quot;/&quot; /&gt;
            &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
        &lt;/bean&gt;
    &lt;/mvc:view-resolvers&gt;

    &lt;!-- 开启SpringMVC注解支持 --&gt;
    &lt;mvc:annotation-driven&gt;
        &lt;!-- 配置消息转换器，将REST返回的对象类型转成JSON --&gt;
        &lt;mvc:message-converters&gt;
            &lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;&gt;
                &lt;property name=&quot;defaultCharset&quot; value=&quot;UTF-8&quot; /&gt;
                &lt;property name=&quot;supportedMediaTypes&quot;&gt;
                    &lt;list&gt;
                        &lt;!-- 这里配置的text/html主要是解决IE浏览器请求JSON会弹出下载框的问题 --&gt;
                        &lt;value&gt;text/html&lt;/value&gt;
                        &lt;value&gt;application/json&lt;/value&gt;
                    &lt;/list&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/mvc:message-converters&gt;
    &lt;/mvc:annotation-driven&gt;

    &lt;!-- 静态资源放行 --&gt;
    &lt;mvc:resources mapping=&quot;/static/**&quot; location=&quot;/static/&quot; /&gt;
&lt;/beans&gt;
</code></pre>
</li>
</ol>
<p>至此，SSM三个框架就整合完成了。 可以编写自己的service代码和controller层代码。放一个项目目录结构图</p>
<figure data-type="image" tabindex="1"><img src="https://klein-moretti.github.io/post-images/1576061791471.png" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据分页]]></title>
        <id>https://klein-moretti.github.io/post/shu-ju-fen-ye</id>
        <link href="https://klein-moretti.github.io/post/shu-ju-fen-ye">
        </link>
        <updated>2017-11-05T11:58:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="数据分页">数据分页</h1>
<h2 id="核心参数">核心参数</h2>
<ul>
<li>总数据条数
<ul>
<li>来源： 后台自己从数据库中查询而来</li>
</ul>
</li>
<li>每页展示条数(pageSize)
<ul>
<li>来源：从前端页面传递过来</li>
</ul>
</li>
<li>总页数（计算得知）
<ul>
<li>来源： 根据总条数和每页展示数量计算得来</li>
</ul>
</li>
<li>当前展示的页码（currentPage)
<ul>
<li>来源：从前端页面传递过来</li>
</ul>
</li>
<li>每页要展示的数据本身
<ul>
<li>来源：后台自己从数据库中查询而来</li>
</ul>
</li>
</ul>
<h2 id="物理分页">物理分页</h2>
<h3 id="概述">概述</h3>
<p>所谓的物理分页其实就是直接通过数据库来实现返回一部分数据。每次只从数据库中查询一页的数据。与之相对应的还有逻辑分页。</p>
<h3 id="mysql中实现语句">Mysql中实现语句</h3>
<pre><code class="language-sql">    SELECT * FROM `shop` LIMIT (currentPage-1)*pageSize, pageSize;
</code></pre>
<h2 id="逻辑分页">逻辑分页</h2>
<p>所谓的逻辑分页其实就是通过内存来进行分页。具体来说，首次查询数据时，将所有数据都取出放到内存中，展示其他页的数据时，在内存中实现数据的截取，展示。</p>
<h2 id="两种分页的对比">两种分页的对比</h2>
<ol>
<li>物理分页节约内存空间，效率相比逻辑分页理论上效率低一些。试用场景：数据量大的时候。</li>
<li>逻辑分页占用空间大，理论上分页性能高一些。试用场景：数据量小，访问用户多。要处理缓存数据同步的问题。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[文件上传]]></title>
        <id>https://klein-moretti.github.io/post/wen-jian-shang-chuan</id>
        <link href="https://klein-moretti.github.io/post/wen-jian-shang-chuan">
        </link>
        <updated>2017-10-17T10:14:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="文件上传">文件上传</h1>
<h2 id="前端页面">前端页面</h2>
<h3 id="必要条件">必要条件</h3>
<ol>
<li>需要有一个form表单</li>
<li>form表单需要设置以下几个属性：
<ol>
<li>action:  提交数据的目的地</li>
<li>method: 设置post</li>
<li>enctype: 设置成multipart/form-data</li>
</ol>
</li>
<li>form里需要至少有一个file域： &lt;input type=&quot;file&quot; name=&quot;xxx&quot; /&gt;</li>
</ol>
<h2 id="后端技术">后端技术</h2>
<p>所谓文件上传其实就是用流的方式，将文件从客户的电脑上通过网页中的表单， 以二进制流的方式，流到服务器的过程。</p>
<p>文件下载就是反过来， 将文件从服务器上通过二进制流的方式流到客户电脑上。</p>
<h3 id="servlet30上传方式">Servlet3.0上传方式</h3>
<h4 id="servlet30上传的核心-一个注解-一个接口">Servlet3.0上传的核心： 一个注解、一个接口</h4>
<p>注解：</p>
<p>@MultipartConfig： 开启Servlet文件上传功能</p>
<p>接口：</p>
<p>javax.servlet.http.Part：  封装了上传的文件相关的所有信息</p>
<h4 id="具体操作步骤">具体操作步骤</h4>
<ol>
<li>新建处理文件上传的Servlet，然后重写doPost方法</li>
<li>给Servlet添加@MultipartConfig注解，开启文件上传功能</li>
<li>Part part = request.getPart(&quot;input type='type' name的值&quot;);</li>
<li>part对象有两个作用：
<ol>
<li>可以获取到上传文件的所有信息，比如：文件名、大小、类型、文件流数据</li>
<li>可以直接将文件写到服务器   part.write(&quot;文件保存的路径&quot;);</li>
</ol>
</li>
</ol>
<h3 id="apache-commons-fileupload-上传方式">Apache Commons Fileupload 上传方式</h3>
<h4 id="用fileupload上传的核心就是一个接口-两个类">用fileupload上传的核心就是：一个接口、两个类</h4>
<p>接口： FileItem</p>
<p>封装了我们表单中的每个域的数据（可能是普通文本数据，也可能是上传的文件）</p>
<p>类：</p>
<p>DiskFileItemFactory：  用于创建文件上传对象的工厂</p>
<p>ServletFileupload： 文件上传对象</p>
<h4 id="具体操作步骤-2">具体操作步骤</h4>
<ol>
<li>
<p>需要添加依赖： commons-fileupload.jar、commons-io.jar</p>
</li>
<li>
<p>新建处理文件上传的Servlet，然后重写doPost方法</p>
</li>
<li>
<p>调用ServletFileupload对象的静态方法，判断请求是否是一个文件上传请求</p>
<pre><code class="language-java">if(!ServletFileupload.isMultipartContent(request)) {
    // 如果不是multipart请求，代表不是一个有效的文件上传请求， 下面的步骤都可以省略了
}
</code></pre>
</li>
<li>
<p>创建文件上传工厂对象：</p>
<pre><code class="language-java">DiskFileItemFactory factory = new DiskFileItemFactory();
// factory.set.... 可以设置相关参数
</code></pre>
</li>
<li>
<p>创建文件上传对象</p>
<pre><code class="language-java">ServletFileupload upload = new ServletFileupload(factory);
// upload.set.... 可以设置相关参数
</code></pre>
</li>
<li>
<p>用文件上传对象解析请求对象，然后获取解析后的所有FileItem</p>
<pre><code class="language-java">List&lt;FileItem&gt; fileItems = upload.parseRequest(request);
</code></pre>
</li>
<li>
<p>迭代处理每个FileItem</p>
<ol>
<li>文本信息的FileItem获取后进行相关的业务操作</li>
<li>文件类型的FileItem获取后，调用FileItem.write将文件写到服务器某个目录下。</li>
</ol>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Cookie&Session 总结]]></title>
        <id>https://klein-moretti.github.io/post/cookieandsession-zong-jie</id>
        <link href="https://klein-moretti.github.io/post/cookieandsession-zong-jie">
        </link>
        <updated>2017-08-17T10:52:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="cookiesession">Cookie&amp;Session</h1>
<h2 id="cookie">Cookie</h2>
<h3 id="cookie是什么-what">Cookie是什么？ （What）</h3>
<p>Cookie是一项在Web请求中，基于客户端的用于存储数据的技术。</p>
<h3 id="为什么要用cookiewhy">为什么要用Cookie？（Why)</h3>
<p>我们知道HTTP协议是一种无状态协议，服务端无法区分每个请求对应的是哪个用户。 Cookie就是为了解决这个问题而生的，它通过在浏览器端存储一些数据，在请求时附加到请求头中，这样服务端一读取请求头就知道了这次请求是哪个用户发起的。</p>
<h3 id="什么情况下要使用cookiewhen">什么情况下要使用Cookie?(When)</h3>
<p>Cookie的使用分为在业务程序中显式使用和通过容器隐式使用。</p>
<ul>
<li>隐式使用： 首次访问JSP、Servlet时，Servlet容器会自动往响应头中添加一个Cookie(Tomcat中是JSESSIONID)</li>
<li>显式使用： 当我们有一些安全性要求不高，数据量不大的用户数据需要存储时，可以考虑使用Cookie</li>
</ul>
<h3 id="怎么使用cookiehow">怎么使用Cookie?（How)</h3>
<h4 id="cookie的创建">Cookie的创建</h4>
<pre><code class="language-java">// 两种方法
// 1. 构造时将数据传入
Cookie cookie = new Cookie(&quot;key&quot;, &quot;value&quot;);

// 2. 构造时无参，然后通过set方法设置数据
Cookie cookie = new Cookie();
cookie.setName(&quot;key&quot;);
cookie.setValue(&quot;value&quot;);


// 除了核心的数据之外，我们还可以设置一些其他属性
// 1. 设置过期时间
cookie.setMaxAge(60);	//单位：秒(60秒后,Cookie会自动删除)
// 2. 设置Domain
cookie.setDomain(&quot;www.baidu.com&quot;); // 代表只有访问www.baidu.com这个域名下的请求，才能获取到此Cookie
cookie.setDomain(&quot;.baidu.com&quot;);	// 代表所有www.baidu.com下的二级域名包括www.baidu.com这个一级域名都可以共享此Cookie（注意这种情况下domain必须以&quot;.&quot;开头）
// 3. 设置Path 
cookie.setPath(&quot;/StudentServlet&quot;);	// 一旦设置了Path，那么要获取Cookie，当前的请求地址必须满足Path的规则，否则获取不到此Cookie     http://xxx:port/student/StudentServlet/getstu/3
</code></pre>
<h4 id="cookie的添加">Cookie的添加</h4>
<pre><code class="language-java">// 使用响应对象写入浏览器

reponse.addCookie(cookie); //本质上会在响应中添加一个Set-Cookie响应头。
</code></pre>
<h4 id="cookie删除">Cookie删除</h4>
<pre><code class="language-java">// Cookie没有delete方法

// 我们可以通过设置过期时间为0实现删除
cookie.setMaxAge(0);
response.addCookie(cookie);
</code></pre>
<h4 id="cookie的修改">Cookie的修改</h4>
<pre><code class="language-java">// Cookie的修改其实就是覆盖添加

// 具体来说分三步
// 1. 先获取已有Cookie，
// 2. 然后修改其中的数据，
// 3. 最后调用response.addCookie()重新添加到浏览器，浏览器看到Key相同的Cookie会自动更新

</code></pre>
<h4 id="获取cookie中的数据">获取Cookie中的数据</h4>
<pre><code class="language-java">// 1. 先通过请求对象获取请求中携带的所有Cookie数组
Cookie[] cookies = request.getCookies();

// 2. 迭代Cookie数组，寻找要操作的Cookie
for(Cookie cookie : cookies) {
    // 根据cookie.getName()判断是否是自己要获取数据的cookie
	
    // 3. 找到后，调用cookie.getValue()获取数据
}
</code></pre>
<h2 id="session">Session</h2>
<h3 id="session是什么-what">Session是什么？ （What）</h3>
<p>Session和Cookie类似，都是用来存储用户信息的。不同于Cookie的是Session是存储在服务器端。他们两者通过JSESSIONID关联起来。</p>
<h3 id="为什么要用sessionwhy">为什么要用Session？（Why)</h3>
<p>虽然Cookie已经可以标识出哪个请求是属于哪个用户的。但是不足的是Cookie本身是存储于客户端硬盘上，安全性不高，不适合存储敏感数据，还有Cookie本身能存储的数据很有限（数据大小本身限制、数据类型限制、字符集限制）。而存储在服务端的Session完全没有这些问题。</p>
<h3 id="什么情况下要使用sessionwhen">什么情况下要使用Session?(When)</h3>
<p>Session可以用来存储用户的所有信息，理论上所有能在Cookie中存储的数据都可以放到Session中。考虑到Session是基于内存的，如果存储太多不太重要的数据会大大增加服务器端内存压力，一般Session会配合Cookie一起使用。</p>
<h3 id="怎么使用sessionhow">怎么使用Session?（How)</h3>
<h4 id="创建session">创建Session</h4>
<pre><code class="language-java">// Session是由容器自动创建的，我们可以在代码中直接获取Sesssion

HttpSession session = request.getSession();
</code></pre>
<h4 id="往session中存储数据">往Session中存储数据</h4>
<pre><code class="language-java">session.setAttribute();
</code></pre>
<h4 id="获取session中的数据">获取Session中的数据</h4>
<pre><code class="language-java">session.getAttribute();
</code></pre>
<h4 id="删除session中的数据">删除Session中的数据</h4>
<pre><code class="language-java">session.removeAttribute();
</code></pre>
<h4 id="修改session中的数据">修改Session中的数据</h4>
<pre><code class="language-java">// 修改Session中的数据和修改Cookie中的数据类似，都是覆盖添加

// 1. 获取要修改的数据
Object data = session.getAttribute(&quot;key&quot;);

// 2. 修改数据对应的属性
data.setXXX();

// 3. 将修改后的数据重新存入Session
session.setAttribute(&quot;key&quot;, data);

</code></pre>
<h4 id="强制让session失效">强制让Session失效</h4>
<pre><code class="language-java">session.invalidate();	//调用后session对象会失效，同时客户端Cookie中的JSESSIONID也会发生变化
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[集合总结]]></title>
        <id>https://klein-moretti.github.io/post/ji-he-zong-jie</id>
        <link href="https://klein-moretti.github.io/post/ji-he-zong-jie">
        </link>
        <updated>2017-06-25T02:07:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="集合框架">集合框架</h1>
<p>集合：简单的说，集合就是一种容器。</p>
<p>集合作为一种容器，里面可以存放内容，存放的每个内容称为是<strong>元素</strong>（element）。</p>
<p>在整个集合框架里一共有2个大类容器：Collection和Map</p>
<h2 id="collection容器interface">Collection容器（interface）</h2>
<p>Collection是元素类容器的根<strong>接口</strong>。</p>
<h4 id="什么是容器">什么是容器</h4>
<p>容器是一个用于存放东西的物件。</p>
<h4 id="容器应该具备什么功能呢什么样的物件叫容器">容器应该具备什么功能呢？（什么样的物件叫容器）</h4>
<ol>
<li>
<p>可以存东西</p>
<p><strong>add(E element)</strong>  //往容器里添加一个元素。元素可以是任意类型（整数，字符串，自定义类，容器）</p>
<p>addAll(Collection c) //往容器里添加多个元素。参数是一个容器，这个方法会把容器里的元素逐一添加进来</p>
</li>
<li>
<p>查看</p>
<p><strong>size()</strong>  //查看容器中包含多少元素</p>
<p><strong>contains(Object o)</strong> //查看是否包含某个元素</p>
<p>containsAll(Collection c) //查看是否包含某些元素</p>
<p>isEmpty() //是不是一个空容器</p>
</li>
<li>
<p>可以提取(删除)东西</p>
<p>clear()  //清空容器</p>
<p><strong>remove(Object o)</strong> //移除一个元素</p>
<p>removeAll(Collection c) //移除参数容器中包含的元素</p>
</li>
<li>
<p>其他</p>
<p>equals(Collection c) //判断是否个另外一个容器相等。</p>
<p>toArray() //把容器转换为数组</p>
</li>
</ol>
<h3 id="listinterface">List（interface）</h3>
<p>list的英文含义是：列表。</p>
<p>list用于定义什么是有序容器。有序容器是容器的一种。</p>
<p>List是一个接口，它有一个父接口Collection。<strong>List相比于Collection多了下标的概念</strong>。用标可以去访问元素。</p>
<p>围绕下标提供了一堆方法：</p>
<ol>
<li>
<p>添加元素</p>
<p><strong>add(int index, E element)</strong> //在指定的位置添加一个元素<br>
addAll(int index, Collection c) //在指定的位置添加多个元素</p>
<p>删除元素</p>
<p><strong>remove(int index)</strong> //移除指定位置的元素</p>
</li>
<li>
<p>获得子列表</p>
<p>subList(int fromIndex, int toIndex) //获取一个子列表  [formIndex, toIndex)</p>
</li>
<li>
<p>更新元素</p>
<p>set(int index, E element)// 把指定下标的元素更新为指定内容</p>
</li>
<li>
<p>获取元素的位置</p>
<p>indexOf(Object o) //获取指定元素的下标（正着查）</p>
<p>lastIndexOf(Object o)//获取指定元素的下标（倒着查）</p>
<p><strong>get(int index)</strong> //获取指定下标的元素</p>
</li>
</ol>
<h3 id="list的实现类">List的实现类</h3>
<h4 id="arraylist">ArrayList</h4>
<p>ArrayList是List的实现类。既然是实现类，说明ArrayList实现了List中定义的所有方法。</p>
<ol>
<li>
<p>如何创建一个ArrayList对象</p>
<p>ArrayList()   //创建一个初始容量为10的列表。列表里尚未存放任何元素。</p>
<p>ArrayList(int capacity) //创建一个指定初始容量的列表。列表里尚未存放任何元素</p>
<blockquote>
<p>初始容量: 列表刚创建时给定的容量。</p>
<p>Collection是个容器，这个容器与之前学过的数组不同，数组是定长的容器，不能减少容量也不能增加容量。但是Collection是一个变长的容器，空间不够的时候可以扩容。</p>
</blockquote>
<p>ArrayList(Collection c) //创建一个包含参数中全部元素的列表。</p>
</li>
<li>
<p>ArrayList的使用</p>
<p>增删改查（API参考 List）</p>
</li>
</ol>
<blockquote>
<p>在创建ArrayList的时候必须指定元素的类型。例如：ArrayList<String></p>
<p>一旦指定ArrayList存放什么类型的数据，以后取元素的时候，无需进行类型转换。</p>
</blockquote>
<ol start="3">
<li>
<p>遍历ArrayList</p>
<p>假定ArrayList内容如下：</p>
</li>
</ol>
<pre><code class="language-java">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
list.add(&quot;张三&quot;);
list.add(&quot;李四&quot;);
list.add(&quot;王五&quot;);
list.add(&quot;赵六&quot;);
</code></pre>
<p>遍历ArrayList的方法有很多，常用方式如下：</p>
<p>一、使用for循环遍历</p>
<pre><code class="language-java">for(int i = 0; i &lt; list.size(); i++){
  String str = list.get(i);
  System.out.println(str);
}
</code></pre>
<blockquote>
<p>使用list.size()获取元素个数， 从下标0开始循环到结束。通过list.get(i) 获取每个元素，达到遍历的效果。</p>
</blockquote>
<p><strong>二、使用迭代器遍历（推荐）</strong></p>
<pre><code class="language-java">Iterator&lt;String&gt; it = list.iterator();//获取迭代器（迭代器会包含list中所有的元素）
while(it.hasNext()){
    String str = it.next();//获取迭代器中的元素，next执行完，迭代器会指向下一个元素。
    System.out.println(str);
}
</code></pre>
<blockquote>
<p>Iterator是一个接口，规定了迭代器应该具有什么功能（hasNext(), next(), remove()）。</p>
<p>hasNext()方法：用于查看是否还有元素。如果迭代器中还有元素，返回true，如果没有元素了，返回false。</p>
<p>next()：获取当前迭代的元素，迭代器指向下一个元素。</p>
<p>remove(): 删除当前迭代到的元素。</p>
</blockquote>
<p>三、使用for..each遍历元素</p>
<pre><code class="language-java">for(String str : list){
    System.out.println(str);//str就是被遍历到的元素。
}
</code></pre>
<blockquote>
<p>for...each是for循环的增强版，有些语言叫for..in</p>
<p>for...each的本质是通过迭代器遍历元素。可通过XJad反编译工具反编译.class文件查看源码。</p>
</blockquote>
<h4 id="arraylist的优势和劣势">ArrayList的优势和劣势</h4>
<p>ArrayList的底层实现是数组，数组最大特点：数据的内存空间是连续的，所以根据下标查找元素是非常非常快。</p>
<p>弊端增加和删除慢，如果要删除下标为0的元素，实际上是通过循环，把下标为1的赋值给下标为0，把下标为2的赋值给下标为1的，以此类推，直到所有元素位置正确。</p>
<p>如果要在下标为0的位置添加一个元素，它也是通过循环实现的，最大下标的元素赋值给最大下标加1的位置，第2大的下标的元素赋值给最大下标，以此类推第0个元素赋值给第1个元素，新元素覆盖下标为0的元素。</p>
<h3 id="list的另外一个实现类-linkedlist">List的另外一个实现类 LinkedList</h3>
<p>LinkedList使用方式同ArrayList。</p>
<p>LinkedList与ArrayList不同，LinkedList底层靠的是双向链表在存储数据。</p>
<p>链表的特点：增删快，查询慢（需要遍历）。</p>
<h3 id="list的另外一个实现类-vector">List的另外一个实现类 Vector</h3>
<p>实现方式和ArrayList几乎一模一样，Vector所有的方法是线程安全的。在线程里，如果不同的线程在访问同一个List（Vector），不会出现数据紊乱（内部加了锁，一个方法执行的时候，其他的方法等待，执行完以后，其他方法才开始执行）。因为考虑的安全性，不断的加锁和解锁，所以效率很低，速度很慢。</p>
<h3 id="如何选择使用哪个list实现类">如何选择使用哪个List实现类？</h3>
<ol>
<li>
<p>看是否在多线程环境下访问。</p>
<p>是：Vector</p>
<p>否：转到2</p>
</li>
<li>
<p>看增删多还是查询多？</p>
<p>增删多：LinkedList</p>
<p>查询多：ArrayList</p>
<p>不知道：ArrayList</p>
</li>
</ol>
<p>List<Type> list = new   xxxx<Type>()<br>
;</p>
<h3 id="setinterface">Set(interface)</h3>
<p>set是一个接口，<strong>用于描述一个元素不重复的容器</strong>。set里面的重复元素只会出现一次。</p>
<p>首先set是一个容器，既然是容器，那么容器所应该具有的功能它都有。也就说Collection接口中定义的方法，Set里都要有。</p>
<p>通过查阅API，发现Set没有自己独有的方法，Set里所有的方法来自于Collection。</p>
<h3 id="set的实现类">Set的实现类</h3>
<h4 id="hashset-普通set">HashSet （普通set）</h4>
<p>HashSet的特点：</p>
<ol>
<li>不重复</li>
<li>无序</li>
</ol>
<blockquote>
<p>注意：如果要往HashSet中添加自定义类型的数据，你需要给自定义的类添加equals方法，HashSet在添加元素的时候，会拿现有元素逐一和要添加的元素比较（用equals比较），如果相等了，就不添加，比较一遍之后没有相等的，把元素加进来。</p>
</blockquote>
<h4 id="hashset的创建">HashSet的创建</h4>
<ol>
<li>
<p>HashSet() //创建一个空的Set，初始容量为16</p>
</li>
<li>
<p>HashSet(int capacity) //创建一个空的Set，初始容量为指定的容量。</p>
</li>
<li>
<p>HashSet(Collection c) //创建一set，初始内容是c中的元素（会去重）。</p>
</li>
</ol>
<p>HashSet的添加和删除元素API见Set</p>
<blockquote>
<p>HashSet没有获取元素的方法，也没有设置元素的方法。</p>
<p>如何取元素呢？---通过遍历来读取。</p>
</blockquote>
<p>思考？</p>
<p>能否使用for循环遍历Set？-----不能！因为没有下标</p>
<h4 id="hashset的遍历">HashSet的遍历</h4>
<p>假定有如下Set：</p>
<pre><code class="language-java">Set&lt;String&gt; s = new HashSet&lt;&gt;();
s.add(&quot;zhangsan&quot;);
s.add(&quot;lisi&quot;);
s.add(&quot;wangwu&quot;);
s.add(&quot;zhaoliu&quot;);
</code></pre>
<ol>
<li>
<p>使用for..each遍历</p>
<pre><code class="language-java">for(String str : s){
    System.out.println(str);//str就是我们set中每个元素
}
</code></pre>
</li>
<li>
<p>使用Iterator遍历</p>
<pre><code class="language-java">Iterator&lt;String&gt; it = s.iterator();
while(it.hasNext()){
  String str = it.next();
  System.out.println(str);
}
</code></pre>
</li>
</ol>
<h4 id="set另外一个实现类-linkedhashset">Set另外一个实现类 LinkedHashSet</h4>
<p>LinkedHashSet是一个有序的不重复的容器。</p>
<p>特点如下：</p>
<ol>
<li>有序（存放顺序有序）</li>
<li>不重复</li>
</ol>
<h3 id="小节">小节</h3>
<p>Collection是什么？</p>
<p>答：它是一个接口。用来描述容器应该具有哪些功能。（add,addAll,clear,remove,contains,size,iterator）</p>
<p>List是什么？</p>
<p>答：它是一个接口,这个接口继承了Colletion。用来描述一个有序的容器。有序指的是存放顺序。提供了下标的概念（index），围绕下标提供了一堆方法。（add(index,object),addAll(index,collection), remove(index),indexOf(object), lastIndexOf(object), get(index),set(index,object)）</p>
<p>List的实现类有哪些？</p>
<p>ArrayList：底层是数组（内存空间连续），查询快，增删慢。</p>
<p>LinkedList：底层是链表，增删快，查询慢。</p>
<p>Vector：线程安全。</p>
<p><strong>List的遍历方法：</strong></p>
<p>for循环</p>
<p>for each</p>
<p><strong>迭代器</strong></p>
<p>Set是什么？</p>
<p>答：set是一个接口，继承于Collection。用来描述不重复的容器。</p>
<p>Set的实现类有哪些？</p>
<p>HashSet：无序不重复。要求容器里的元素实现了equals方法。</p>
<p>LinkedHashSet：有序不重复。有序指的是存放顺序。也需要元素实现equals放法。</p>
<p>TreeSet：有序不重复。有序指的是内容有序。</p>
<h3 id="treeset-是一个set的实现类">TreeSet 是一个Set的实现类</h3>
<p>TreeSet是一个不重复的容器，而且内容有序。靠Comparable或者Comparator来实现比较，确定是否重复以及谁大谁小。</p>
<p>TreeSet有2大类创建方式：</p>
<ol>
<li>自然排序。 元素本身带有比较方法（本质是元素实现了Comparable接口）</li>
<li>比较器排序。元素本身不具备比较的能力，比较帮元素比较大小。</li>
</ol>
<p>TreeSet底层靠的二叉树来实现内容有序。小的元素放在树的左分支上，大的放在右分支上。读取元素时，TreeSet使用中序遍历的方式读取元素。</p>
<p>TreeSet添加元素以及删除元素和HashSet一样。</p>
<h3 id="小节-2">小节</h3>
<p>Collection描述一个容器</p>
<p>​	List：有序容器，可重复</p>
<p>​		ArrayList： 数组</p>
<p>​		LinkedList： 链表</p>
<p>​		Vector：数组</p>
<p>​	Set：不可重复，通常是无序的。</p>
<p>​		HashSet：普通集合</p>
<p>​		LinkedHashSet：存放顺序有序，不可重复</p>
<p>​		TreeSet：内容有序，不可重读</p>
<h2 id="map接口">Map（接口）</h2>
<p>Map是用来描述一个容器，用来描述一个键值对容器。</p>
<p>Map的特点：键不允许重复。</p>
<p>Map和Colletion是平级的。Map数据键值对接口中的根接口。</p>
<ol>
<li>
<p>添加元素到Map中</p>
<p><strong>put(key, value)</strong> //往Map中存放元素，如果Map中已经有这个key了，会覆盖。如果Map中没有这个key，会把这个键值对存入map</p>
<p>putAll(Map map) //把另外一个map中的元素全部添加到当前map中，如果有key已经存在了，会产生覆盖。</p>
</li>
<li>
<p>移除元素</p>
<p><strong>remove(key)</strong> //根据key移除对应的键值对。</p>
</li>
<li>
<p>修改元素</p>
<p>put(key, value) //如果Map中已经有这个key了，会覆盖. 如果没有就是添加</p>
</li>
<li>
<p>查看Map</p>
<p><strong>size()</strong> //查看里面有多少键值对</p>
<p>containsKey(key) //查看是否有某个key</p>
<p>containsValue(value) //查看是否有某个value</p>
<p><strong>get(key)</strong> //获取key对应的值。</p>
<p><strong>keySet()</strong> //获取所有的key</p>
<p>values() //获取所有的value</p>
<p><strong>entrySet</strong> //获取键值对集合</p>
</li>
</ol>
<h2 id="map的实现类">Map的实现类</h2>
<h3 id="hashmap">HashMap</h3>
<p>HashMap是一个普通的Map。</p>
<h4 id="创建hashmap">创建HashMap</h4>
<ol>
<li>HashMap()  创建一个空的Map，初始容量是16， 加载因子是0.75</li>
<li>HashMap(int capacity) 创建一个空的Map， 初始容量为指定的容量，加载因子是0.75</li>
<li>HashMap(int capacity, float loadFactor) 创建一个空的Map，初始容量和加载因子由参数指定。</li>
<li>HashMap(Map map) 创建一个包含指定键值对的Map。</li>
</ol>
<h3 id="hashmap的使用">HashMap的使用</h3>
<p>增删改查 见Map的API</p>
<h3 id="map的遍历">Map的遍历</h3>
<p>假定有如下Map：</p>
<pre><code class="language-java">Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
map.put(&quot;one&quot;, 100);
map.put(&quot;two&quot;, 88);
map.put(&quot;three&quot;, 96);
map.put(&quot;four&quot;, 88);
</code></pre>
<p>for each遍历</p>
<pre><code class="language-java">Set&lt;String&gt; keys = map.keySet();
for(String key : keys) {
	System.out.println(key+ &quot;----&quot; + map.get(key));
}
</code></pre>
<p>使用迭代器遍历</p>
<pre><code class="language-java">Iterator&lt;String&gt; it = keys.iterator();
while(it.hasNext()) {
	String key = it.next();
	int value = map.get(key);
	System.out.println(key + &quot;===&quot; + value);
}
</code></pre>
<p>for each遍历键值对</p>
<pre><code class="language-java">Set&lt;Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();
for(Entry&lt;String, Integer&gt; e : entries) {
	System.out.println(e.getKey()+ &quot;__&quot;+ e.getValue());
}
</code></pre>
<blockquote>
<p>Entry是专门服务于Map的类。它代表键值对对象，内部含有键和值。如果要取出键和值，使用getKey()以及getValue().</p>
<p>Entry本质上Map中内部类。</p>
</blockquote>
<p>迭代器遍历键值对</p>
<pre><code class="language-java">Iterator&lt;Entry&lt;String,Integer&gt;&gt; it2 = entries.iterator();
while(it2.hasNext()) {
	Entry&lt;String, Integer&gt; e = it2.next();
	System.out.println(e.getKey()+&quot;  &quot;+e.getValue());
}
</code></pre>
<h4 id="linkedhashmap">LinkedHashMap</h4>
<p>存放顺序有序的Map。特点：存放顺序有序，键不能重复。</p>
<h4 id="treemap">TreeMap</h4>
<p>key的内容有序的Map。特点：key的内容有序，键不能重复。</p>
<h4 id="hashtable">HashTable</h4>
<p>它与HashMap非常类似，只不过HashTable是线程安全的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面向对象   继承, super, 重写, 访问控制]]></title>
        <id>https://klein-moretti.github.io/post/mian-xiang-dui-xiang-ji-cheng-super-chong-xie-fang-wen-kong-zhi</id>
        <link href="https://klein-moretti.github.io/post/mian-xiang-dui-xiang-ji-cheng-super-chong-xie-fang-wen-kong-zhi">
        </link>
        <updated>2017-02-10T10:38:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一什么是继承">一,什么是继承,</h2>
<p>​	生活中的继承: 子承父业</p>
<h2 id="二为什么要使用继承">二,为什么要使用继承</h2>
<p>​	多个类中存在相同的属性和方法时, 将这些内容抽取到单独的一个类中,那么多个类无需再定义这些属性和行为, 只需从这个类继承即可, 用来提高代码的复用性, 以及可维护性.</p>
<h2 id="三java中继承的语法格式">三,Java中继承的语法格式</h2>
<p>​	Java中使用extends关键字 实现一个类从另外一个类继承, 那么extends关键字的含义是”扩展”.</p>
<pre><code class="language-java">class A extends class B{

}
</code></pre>
<p>A从B继承, A是B的子类, 派生类,SubClass, B是A的父类, 也叫做基类,超类,SuperClass</p>
<p>​    通过继承, 子类可以继承父类中所有的属性和方法.(私有的方法及构造器除外)</p>
<h2 id="四继承的注意事项">四,继承的注意事项.</h2>
<ol>
<li>Java祖宗类: java.lang.Object.,所有的类都是源自于它.</li>
<li>子类不能单纯的为了获得父类的东西而使用继承, 使用继承时要能够被描述成所属关系is a. 比如学生是个人, 老师是个人.</li>
<li>JAVA里面只支持单继承, 不支持多继承, 支持多层继承(子类还可以再有子类).</li>
</ol>
<h2 id="五-继承之后属性的特点">五, 继承之后属性的特点</h2>
<ol>
<li>如果类中出现了和父类同名的属性的时候,创建子类对象,调用该属性, 使用的是子类的</li>
<li>如果需要使用父类的,可以使用super关键字, 使用super可以访问父类的属性,方法,和构造器, super.属性, super.方法, super(...)构造器</li>
</ol>
<pre><code>PS:super的使用方法和this一模一样, super.属性, super.方法, super()调用父类构造器, this使用在本类中,代表当前对象. super使用在子类中, 访问父类的成员, super仅仅是个关键字,不是引用.
</code></pre>
<ol start="3">
<li>子类从父类继承之后, 子类可以获得父类所有的属性和方法, (私有方法和构造器除外),父类修饰成private的属性, 子类不能直接访问, 但可以通过公共的set/get方法间接访问</li>
</ol>
<h2 id="六-方法重写override">六, 方法重写Override</h2>
<h3 id="1为什么要使用方法重写">1.为什么要使用方法重写</h3>
<ol>
<li>当父类方法实现不能够满足子类需求时, 子类可以对父类方法进行重写</li>
<li>因为子类是父类的扩展, 当子类对父类方法进行重写后, 需要保留父类方法实现, 可以在重写方法中, 使用super.调用父类方法实现.</li>
</ol>
<h3 id="2方法重写注意事项">2.方法重写注意事项</h3>
<ol>
<li>必须要有继承</li>
<li>方法名, 参数列表必须一致.</li>
<li>访问修饰符可以不一样,但是子类的访问修饰符不能够小于父类的访问修饰符. 如,父类是默认, 子类是public</li>
<li>返回值可以不一样, 但是子类重写方法的” 返回值类型”,必须是” 父类返回值类型”的子类</li>
<li>通常重写方法需要加上@Override注解, 做重写方法检查</li>
</ol>
<h2 id="七方法重载和方法重写的区别">七:方法重载和方法重写的区别</h2>
<p><strong>方法重载:</strong></p>
<p>1.方法名相同</p>
<p>2.参数列表不同(参数个数, 参数类型)</p>
<p>3.与返回值类型无关</p>
<p><strong>方法重写同6-2</strong></p>
<h2 id="八继承后构造器的特点">八,继承后构造器的特点</h2>
<p>1.当子类继承父类后, 子类中所有的构造器的第一句,都有一个隐式的:super().</p>
<p>super()的作用, 是调用父类无参的构造器.</p>
<p>super()的目的, 当子类继承父类后,继承了父类所有的属性和方法, 因此,子类需要知道父类是如何为对象进行初始化的.</p>
<p>2.如果父类中没有显式定义无参构造, 只给了有参构造, 那么子类的构造器中,就不能使用super(),</p>
<p><strong>解决方法:</strong></p>
<p>1.父类显式提供一个无参构造</p>
<p>2.子类构造器中, 显式调用父类有参构造, 如果子类显式调用了父类的有参构造super(参数),  子类构造隐式的super()将不再提供.</p>
<p>3.子类所有的构造器里, 默认都有一个隐式的super().</p>
<p>4.super() 必须出现在当前构造器中的首行 ,</p>
<p>5.super() 和this() 不能同时出现(指的是super和this调用构造方法)</p>
<h2 id="九访问控制修饰符">九:访问控制修饰符</h2>
<table>
<thead>
<tr>
<th>权限修饰符</th>
<th>本类</th>
<th>同一个包下</th>
<th>不同包下</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>子类</td>
<td>无关类</td>
<td>子类</td>
<td>无关类</td>
<td></td>
<td></td>
</tr>
<tr>
<td>private(私有)</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>默认(不写)</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected(受保护的)</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td></td>
</tr>
<tr>
<td>public(公共的)</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody>
</table>
<p><strong>public:</strong> 公共的, 可用于修饰属性,方法,类, 可以在任何地方访问.</p>
<p><strong>protected:</strong> 受保护的, 可用于修饰属性,方法, 只能在本类中, 本包中, 子类中使用</p>
<p><strong>default:</strong> 默认的(缺省的), 可用于修饰属性,方法,和类. 只能在本类中, 本包中使用 (并不是关键字, 什么都不写就是default)</p>
<p><strong>private:</strong> 私有的, 可用于修饰属性, 方法, 只能在本类中使用.</p>
]]></content>
    </entry>
</feed>