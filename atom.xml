<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://klein-moretti.github.io</id>
    <title>Gridea</title>
    <updated>2019-12-11T11:59:30.882Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://klein-moretti.github.io"/>
    <link rel="self" href="https://klein-moretti.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://klein-moretti.github.io/images/avatar.png</logo>
    <icon>https://klein-moretti.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[JAVA常见异常状态码]]></title>
        <id>https://klein-moretti.github.io/post/java-chang-jian-yi-chang-zhuang-tai-ma</id>
        <link href="https://klein-moretti.github.io/post/java-chang-jian-yi-chang-zhuang-tai-ma">
        </link>
        <updated>2018-11-26T11:34:21.000Z</updated>
        <content type="html"><![CDATA[<p>4xx（请求错误）<br>
这些状态代码表示请求可能出错，妨碍了服务器的处理。</p>
<p>代码 说明<br>
==400 ==（错误请求） 服务器不理解请求的语法。<br>
401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>
403 （禁止） 服务器拒绝请求。<br>
404 （未找到） 服务器找不到请求的网页。<br>
405 （方法禁用） 禁用请求中指定的方法。<br>
406 （不接受） 无法使用请求的内容特性响应请求的网页。<br>
407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。<br>
408 （请求超时） 服务器等候请求时发生超时。<br>
409 （冲突） 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。<br>
410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。<br>
411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。<br>
412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。<br>
413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。<br>
414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。<br>
415 （不支持的媒体类型） 请求的格式不受请求页面的支持。<br>
416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。<br>
417 （未满足期望值） 服务器未满足&quot;期望&quot;请求标头字段的要求。</p>
<p>5xx（服务器错误）<br>
这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p>
<p>代码 说明<br>
500 （服务器内部错误） 服务器遇到错误，无法完成请求。<br>
501 （尚未实施） 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。<br>
502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。<br>
503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。<br>
504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>
505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux常用命令]]></title>
        <id>https://klein-moretti.github.io/post/linux-chang-yong-ming-ling</id>
        <link href="https://klein-moretti.github.io/post/linux-chang-yong-ming-ling">
        </link>
        <updated>2018-10-12T08:28:43.000Z</updated>
        <content type="html"><![CDATA[<p>目录结构：<br>
https://www.runoob.com/linux/linux-system-contents.html</p>
<ol>
<li>在虚拟机中安装Centos操作系统<br>
使用VirtualBox虚拟机工具安装centos6操作系统</li>
</ol>
<p>**1.1 Linux **SSH操作终端<br>
使用SecureCRT工具通过ssh服务远程连接到linux，通过命令行操作</p>
<p>1.2. Linux常用命令<br>
目录相关命令：<br>
ls: 查看当前目录文件</p>
<p>ll:查看所有以及</p>
<p>cd: 切换工作目录 如: cd ~ （进入当前用户home目录）</p>
<p>pwd: 显示当前工作目录</p>
<p>mkdir: 新建目录</p>
<p>mkdir -p /././. :创建多级目录</p>
<p>cd … :跳出到根目录（到上一级目录 ）</p>
<p>ls-命令参数 :</p>
<p>-a 显示所有文件及目录 (ls内定将文件名或目录名称开头为&quot;.&quot;的视为隐藏档，不会列出)<br>
-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出<br>
-r 将文件以相反次序显示(原定依英文字母次序)<br>
-t 将文件依建立时间之先后次序列出<br>
-A 同 -a ，但不列出 “.” (目前目录) 及 “…” (父目录)<br>
-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/”<br>
-R 若目录下有文件，则以下之文件亦皆依序列出<br>
文件操作相关：<br>
cat: 查看文件内容</p>
<p>tail -fn 100 /etc/passwd （查看文件最后100行， 自动刷新，非常适合看日志）</p>
<p>rm: 删除</p>
<p>mv: 移动文件 (如果还移动到当前目录，就是重命名)</p>
<p>touch: 创建一个空文件</p>
<p>sz [文件名] ：下载Linux上的文件到本地系统</p>
<p>使用指令&quot;cp&quot;将当前目录&quot;test/&quot;下的所有文件复制到新目录&quot;newtest&quot;下，输入如下命令：</p>
<p>$ cp –r test/ newtest<br>
1<br>
**我们知道cp是复制，mv就是剪切，在windows下的叫法，在linux下二者还有一个区别，就是生成的文件的权限不一定相同。</p>
<p>**mv只是移动了文件，文件的一切都没有改变，而cp是在目标文件夹中创建了新的文件。</p>
<p>VIM 文本编辑相关：<br>
vim: linux上的一个强大的文本编辑器</p>
<p>保存并退出： :wq(命令模式下)、 ZZ（命令模式下）</p>
<p>不保存退出：:q! (命令模式下)</p>
<p>从命令模式切换到编辑模式： a、i、o</p>
<p>跳到文件头： gg</p>
<p>跳到文件尾：GG</p>
<p>进程相关命令：<br>
查看当前系统中运行了哪些进程：ps aux | grep vsftp (查看当前有没有运行ftp进程)</p>
<p>杀进程： kill -9 [进程号]</p>
<p>Centos安装包管理器Yum 命令：<br>
查看已安装的程序：sudo yum list installed | grep vsftp (查看是否安装了vsftp软件)</p>
<p>卸载已安装程序： sudo yum remove vsftpd.i686</p>
<p>安装程序： sudo yum install vsftpd</p>
<p>Centos防火墙命令相关:<br>
查看防火墙状态：service iptables status</p>
<p>关闭防火墙：service iptables stop</p>
<p>开启防火墙：service iptables start</p>
<p>服务开机自启动：<br>
chkconfig vsftpd on (设置vsftpd服务开机自启动)</p>
<p>关机服务开机自启：<br>
chkconfig iptables off (设置防火墙服务不开机自启)</p>
<p>关机：sudo halt –p</p>
<p>重启: sudo reboot</p>
<p>用户相关：<br>
useradd user1——创建用户user1</p>
<p>使用 passwd 命令为新建用户设置密码：password user1</p>
<p>命令 usermod 修改用户账户：usermod –l u1 user1 改名字</p>
<p>usermod –g users user1 ：加入用户组</p>
<p>su user :查询进入用户</p>
<p>sudo password user：重置这个用户的密码</p>
<p>删除用户：userdel user2</p>
<p>删除用户 user3，同时删除他的工作目录：userdel –r user3</p>
<p>d命令查看一个用户的UID和GID, 例：查看user4的id：：id user4<br>
finger命令 ——可以查看用户的主目录、启动shell、用户名、地址、电话等信息</p>
<p>命令 groupadd创建用户组：：groupadd –g 888 users ：：创建一个组users，其GID为888</p>
<p>两种方式，我们以kill用户user为例:</p>
<p>pkill方式<br>
pkill -u user</p>
<p>killall方式<br>
killall -u user</p>
<p>其他：<br>
sudo make &amp;&amp; make install：同时执行多个简单的命令</p>
<p>./configure\：后面的\是转义，代表不换行太长了继续编辑</p>
<p>ps aux | grep nginx ：查看是否启动（也是查看有无进程）</p>
<p>wget url ：直接根据url链接下载</p>
<p>rz -be:上传本地的文件到Linux</p>
<p>tar -zxf 。。。。：解压tar包</p>
<p>语法：unzip ［选项］ 压缩文件名.zip</p>
<p>sudo ./nginx -s reload :热加载（修改了配置文件后不重启，热加载让其生效！）</p>
<p>查看虚拟机IP：：ip address</p>
<p>ll -a | grep sudoers ：查看文件权限</p>
<p>chmod 664 sudoers：添加文件权限</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[三大框架整合]]></title>
        <id>https://klein-moretti.github.io/post/san-da-kuang-jia-zheng-he</id>
        <link href="https://klein-moretti.github.io/post/san-da-kuang-jia-zheng-he">
        </link>
        <updated>2018-05-13T14:55:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="ssm整合步骤">SSM整合步骤</h1>
<h2 id="spring和mybatis整合">Spring和Mybatis整合</h2>
<ol>
<li>
<p>加入Spring、mybatis的依赖</p>
<pre><code class="language-xml">&lt;!-- Spring相关依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- mybatis相关依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
    &lt;version&gt;3.4.6&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- Spring、Mybatis整合依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;version&gt;1.3.2&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- mysql驱动 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;5.1.47&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>在Spring bean配置文件中，配置整合的Bean</p>
<p>在类路径下新建applicationContext.xml文件，做如下配置：</p>
<ol>
<li>
<p>配置数据源</p>
<pre><code class="language-xml">&lt;context:property-placeholder location=&quot;classpath*:/jdbc.properties&quot; /&gt;
&lt;!-- 连接池 --&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;
    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;
    &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;
    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>配置SqlSessionFactoryBean</p>
<pre><code class="language-xml">&lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
    &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.lanou3g.ssm.bean&quot; /&gt;
    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:/mybatis/mappers/*.xml&quot; /&gt;
&lt;/bean&gt;
</code></pre>
</li>
</ol>
</li>
<li>
<p>编写mybatis的mapper映射文件、mapper接口、核心配置文件(可选)</p>
<blockquote>
<p>mapper映射文件和mapper接口可直接用mybatis逆向工程生成</p>
</blockquote>
</li>
<li>
<p>配置扫描包路径</p>
<pre><code class="language-xml">&lt;context:component-scan base-package=&quot;com.lanou3g.ssm.service&quot;  /&gt;
</code></pre>
</li>
<li>
<p>配置mapper接口扫描路径</p>
<pre><code class="language-xml">&lt;mybatis:scan base-package=&quot;com.lanou3g.ssm.mapper&quot; /&gt;
</code></pre>
<blockquote>
<p>作用是让mybatis去指定的包下找Mapper接口，生成实现类，注入到IOC容器中</p>
</blockquote>
</li>
</ol>
<h2 id="spring和springmvc">Spring和SpringMVC</h2>
<ol>
<li>
<p>添加SpringMVC依赖和Servlet、JSTL依赖</p>
<pre><code class="language-xml">&lt;!-- SpringMVC依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- Servlet api 依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
    &lt;version&gt;3.1.0&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;jstl&lt;/artifactId&gt;
    &lt;version&gt;1.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>配置SpringMVC</p>
<p>web.xml</p>
<pre><code class="language-xml">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee
                      http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot;&gt;

  &lt;!-- 配置root applicationContext --&gt;
  &lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;classpath*:application*.xml&lt;/param-value&gt;
  &lt;/context-param&gt;

  &lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
  &lt;/listener&gt;

  &lt;!-- 配置请求编码 --&gt;
  &lt;filter&gt;
    &lt;filter-name&gt;charchaterFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;encoding&lt;/param-name&gt;
      &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
  &lt;/filter&gt;
  &lt;filter-mapping&gt;
    &lt;filter-name&gt;charchaterFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;

  &lt;!-- 配置DispatcherServlet大总管 --&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;

&lt;/web-app&gt;
</code></pre>
<p>dispatcher-servlet.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!-- 配置扫描Controller的包路径 --&gt;
    &lt;context:component-scan base-package=&quot;com.lanou3g.ssm.web&quot; /&gt;

    &lt;!-- 配置视图解析器 --&gt;
    &lt;mvc:view-resolvers&gt;
        &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
            &lt;property name=&quot;prefix&quot; value=&quot;/&quot; /&gt;
            &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
        &lt;/bean&gt;
    &lt;/mvc:view-resolvers&gt;

    &lt;!-- 开启SpringMVC注解支持 --&gt;
    &lt;mvc:annotation-driven&gt;
        &lt;!-- 配置消息转换器，将REST返回的对象类型转成JSON --&gt;
        &lt;mvc:message-converters&gt;
            &lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;&gt;
                &lt;property name=&quot;defaultCharset&quot; value=&quot;UTF-8&quot; /&gt;
                &lt;property name=&quot;supportedMediaTypes&quot;&gt;
                    &lt;list&gt;
                        &lt;!-- 这里配置的text/html主要是解决IE浏览器请求JSON会弹出下载框的问题 --&gt;
                        &lt;value&gt;text/html&lt;/value&gt;
                        &lt;value&gt;application/json&lt;/value&gt;
                    &lt;/list&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/mvc:message-converters&gt;
    &lt;/mvc:annotation-driven&gt;

    &lt;!-- 静态资源放行 --&gt;
    &lt;mvc:resources mapping=&quot;/static/**&quot; location=&quot;/static/&quot; /&gt;
&lt;/beans&gt;
</code></pre>
</li>
</ol>
<p>至此，SSM三个框架就整合完成了。 可以编写自己的service代码和controller层代码。放一个项目目录结构图</p>
<figure data-type="image" tabindex="1"><img src="https://klein-moretti.github.io/post-images/1576061791471.png" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据分页]]></title>
        <id>https://klein-moretti.github.io/post/shu-ju-fen-ye</id>
        <link href="https://klein-moretti.github.io/post/shu-ju-fen-ye">
        </link>
        <updated>2017-11-05T11:58:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="数据分页">数据分页</h1>
<h2 id="核心参数">核心参数</h2>
<ul>
<li>总数据条数
<ul>
<li>来源： 后台自己从数据库中查询而来</li>
</ul>
</li>
<li>每页展示条数(pageSize)
<ul>
<li>来源：从前端页面传递过来</li>
</ul>
</li>
<li>总页数（计算得知）
<ul>
<li>来源： 根据总条数和每页展示数量计算得来</li>
</ul>
</li>
<li>当前展示的页码（currentPage)
<ul>
<li>来源：从前端页面传递过来</li>
</ul>
</li>
<li>每页要展示的数据本身
<ul>
<li>来源：后台自己从数据库中查询而来</li>
</ul>
</li>
</ul>
<h2 id="物理分页">物理分页</h2>
<h3 id="概述">概述</h3>
<p>所谓的物理分页其实就是直接通过数据库来实现返回一部分数据。每次只从数据库中查询一页的数据。与之相对应的还有逻辑分页。</p>
<h3 id="mysql中实现语句">Mysql中实现语句</h3>
<pre><code class="language-sql">    SELECT * FROM `shop` LIMIT (currentPage-1)*pageSize, pageSize;
</code></pre>
<h2 id="逻辑分页">逻辑分页</h2>
<p>所谓的逻辑分页其实就是通过内存来进行分页。具体来说，首次查询数据时，将所有数据都取出放到内存中，展示其他页的数据时，在内存中实现数据的截取，展示。</p>
<h2 id="两种分页的对比">两种分页的对比</h2>
<ol>
<li>物理分页节约内存空间，效率相比逻辑分页理论上效率低一些。试用场景：数据量大的时候。</li>
<li>逻辑分页占用空间大，理论上分页性能高一些。试用场景：数据量小，访问用户多。要处理缓存数据同步的问题。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[文件上传]]></title>
        <id>https://klein-moretti.github.io/post/wen-jian-shang-chuan</id>
        <link href="https://klein-moretti.github.io/post/wen-jian-shang-chuan">
        </link>
        <updated>2017-10-17T10:14:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="文件上传">文件上传</h1>
<h2 id="前端页面">前端页面</h2>
<h3 id="必要条件">必要条件</h3>
<ol>
<li>需要有一个form表单</li>
<li>form表单需要设置以下几个属性：
<ol>
<li>action:  提交数据的目的地</li>
<li>method: 设置post</li>
<li>enctype: 设置成multipart/form-data</li>
</ol>
</li>
<li>form里需要至少有一个file域： &lt;input type=&quot;file&quot; name=&quot;xxx&quot; /&gt;</li>
</ol>
<h2 id="后端技术">后端技术</h2>
<p>所谓文件上传其实就是用流的方式，将文件从客户的电脑上通过网页中的表单， 以二进制流的方式，流到服务器的过程。</p>
<p>文件下载就是反过来， 将文件从服务器上通过二进制流的方式流到客户电脑上。</p>
<h3 id="servlet30上传方式">Servlet3.0上传方式</h3>
<h4 id="servlet30上传的核心-一个注解-一个接口">Servlet3.0上传的核心： 一个注解、一个接口</h4>
<p>注解：</p>
<p>@MultipartConfig： 开启Servlet文件上传功能</p>
<p>接口：</p>
<p>javax.servlet.http.Part：  封装了上传的文件相关的所有信息</p>
<h4 id="具体操作步骤">具体操作步骤</h4>
<ol>
<li>新建处理文件上传的Servlet，然后重写doPost方法</li>
<li>给Servlet添加@MultipartConfig注解，开启文件上传功能</li>
<li>Part part = request.getPart(&quot;input type='type' name的值&quot;);</li>
<li>part对象有两个作用：
<ol>
<li>可以获取到上传文件的所有信息，比如：文件名、大小、类型、文件流数据</li>
<li>可以直接将文件写到服务器   part.write(&quot;文件保存的路径&quot;);</li>
</ol>
</li>
</ol>
<h3 id="apache-commons-fileupload-上传方式">Apache Commons Fileupload 上传方式</h3>
<h4 id="用fileupload上传的核心就是一个接口-两个类">用fileupload上传的核心就是：一个接口、两个类</h4>
<p>接口： FileItem</p>
<p>封装了我们表单中的每个域的数据（可能是普通文本数据，也可能是上传的文件）</p>
<p>类：</p>
<p>DiskFileItemFactory：  用于创建文件上传对象的工厂</p>
<p>ServletFileupload： 文件上传对象</p>
<h4 id="具体操作步骤-2">具体操作步骤</h4>
<ol>
<li>
<p>需要添加依赖： commons-fileupload.jar、commons-io.jar</p>
</li>
<li>
<p>新建处理文件上传的Servlet，然后重写doPost方法</p>
</li>
<li>
<p>调用ServletFileupload对象的静态方法，判断请求是否是一个文件上传请求</p>
<pre><code class="language-java">if(!ServletFileupload.isMultipartContent(request)) {
    // 如果不是multipart请求，代表不是一个有效的文件上传请求， 下面的步骤都可以省略了
}
</code></pre>
</li>
<li>
<p>创建文件上传工厂对象：</p>
<pre><code class="language-java">DiskFileItemFactory factory = new DiskFileItemFactory();
// factory.set.... 可以设置相关参数
</code></pre>
</li>
<li>
<p>创建文件上传对象</p>
<pre><code class="language-java">ServletFileupload upload = new ServletFileupload(factory);
// upload.set.... 可以设置相关参数
</code></pre>
</li>
<li>
<p>用文件上传对象解析请求对象，然后获取解析后的所有FileItem</p>
<pre><code class="language-java">List&lt;FileItem&gt; fileItems = upload.parseRequest(request);
</code></pre>
</li>
<li>
<p>迭代处理每个FileItem</p>
<ol>
<li>文本信息的FileItem获取后进行相关的业务操作</li>
<li>文件类型的FileItem获取后，调用FileItem.write将文件写到服务器某个目录下。</li>
</ol>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Cookie&Session 总结]]></title>
        <id>https://klein-moretti.github.io/post/cookieandsession-zong-jie</id>
        <link href="https://klein-moretti.github.io/post/cookieandsession-zong-jie">
        </link>
        <updated>2017-08-17T10:52:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="cookiesession">Cookie&amp;Session</h1>
<h2 id="cookie">Cookie</h2>
<h3 id="cookie是什么-what">Cookie是什么？ （What）</h3>
<p>Cookie是一项在Web请求中，基于客户端的用于存储数据的技术。</p>
<h3 id="为什么要用cookiewhy">为什么要用Cookie？（Why)</h3>
<p>我们知道HTTP协议是一种无状态协议，服务端无法区分每个请求对应的是哪个用户。 Cookie就是为了解决这个问题而生的，它通过在浏览器端存储一些数据，在请求时附加到请求头中，这样服务端一读取请求头就知道了这次请求是哪个用户发起的。</p>
<h3 id="什么情况下要使用cookiewhen">什么情况下要使用Cookie?(When)</h3>
<p>Cookie的使用分为在业务程序中显式使用和通过容器隐式使用。</p>
<ul>
<li>隐式使用： 首次访问JSP、Servlet时，Servlet容器会自动往响应头中添加一个Cookie(Tomcat中是JSESSIONID)</li>
<li>显式使用： 当我们有一些安全性要求不高，数据量不大的用户数据需要存储时，可以考虑使用Cookie</li>
</ul>
<h3 id="怎么使用cookiehow">怎么使用Cookie?（How)</h3>
<h4 id="cookie的创建">Cookie的创建</h4>
<pre><code class="language-java">// 两种方法
// 1. 构造时将数据传入
Cookie cookie = new Cookie(&quot;key&quot;, &quot;value&quot;);

// 2. 构造时无参，然后通过set方法设置数据
Cookie cookie = new Cookie();
cookie.setName(&quot;key&quot;);
cookie.setValue(&quot;value&quot;);


// 除了核心的数据之外，我们还可以设置一些其他属性
// 1. 设置过期时间
cookie.setMaxAge(60);	//单位：秒(60秒后,Cookie会自动删除)
// 2. 设置Domain
cookie.setDomain(&quot;www.baidu.com&quot;); // 代表只有访问www.baidu.com这个域名下的请求，才能获取到此Cookie
cookie.setDomain(&quot;.baidu.com&quot;);	// 代表所有www.baidu.com下的二级域名包括www.baidu.com这个一级域名都可以共享此Cookie（注意这种情况下domain必须以&quot;.&quot;开头）
// 3. 设置Path 
cookie.setPath(&quot;/StudentServlet&quot;);	// 一旦设置了Path，那么要获取Cookie，当前的请求地址必须满足Path的规则，否则获取不到此Cookie     http://xxx:port/student/StudentServlet/getstu/3
</code></pre>
<h4 id="cookie的添加">Cookie的添加</h4>
<pre><code class="language-java">// 使用响应对象写入浏览器

reponse.addCookie(cookie); //本质上会在响应中添加一个Set-Cookie响应头。
</code></pre>
<h4 id="cookie删除">Cookie删除</h4>
<pre><code class="language-java">// Cookie没有delete方法

// 我们可以通过设置过期时间为0实现删除
cookie.setMaxAge(0);
response.addCookie(cookie);
</code></pre>
<h4 id="cookie的修改">Cookie的修改</h4>
<pre><code class="language-java">// Cookie的修改其实就是覆盖添加

// 具体来说分三步
// 1. 先获取已有Cookie，
// 2. 然后修改其中的数据，
// 3. 最后调用response.addCookie()重新添加到浏览器，浏览器看到Key相同的Cookie会自动更新

</code></pre>
<h4 id="获取cookie中的数据">获取Cookie中的数据</h4>
<pre><code class="language-java">// 1. 先通过请求对象获取请求中携带的所有Cookie数组
Cookie[] cookies = request.getCookies();

// 2. 迭代Cookie数组，寻找要操作的Cookie
for(Cookie cookie : cookies) {
    // 根据cookie.getName()判断是否是自己要获取数据的cookie
	
    // 3. 找到后，调用cookie.getValue()获取数据
}
</code></pre>
<h2 id="session">Session</h2>
<h3 id="session是什么-what">Session是什么？ （What）</h3>
<p>Session和Cookie类似，都是用来存储用户信息的。不同于Cookie的是Session是存储在服务器端。他们两者通过JSESSIONID关联起来。</p>
<h3 id="为什么要用sessionwhy">为什么要用Session？（Why)</h3>
<p>虽然Cookie已经可以标识出哪个请求是属于哪个用户的。但是不足的是Cookie本身是存储于客户端硬盘上，安全性不高，不适合存储敏感数据，还有Cookie本身能存储的数据很有限（数据大小本身限制、数据类型限制、字符集限制）。而存储在服务端的Session完全没有这些问题。</p>
<h3 id="什么情况下要使用sessionwhen">什么情况下要使用Session?(When)</h3>
<p>Session可以用来存储用户的所有信息，理论上所有能在Cookie中存储的数据都可以放到Session中。考虑到Session是基于内存的，如果存储太多不太重要的数据会大大增加服务器端内存压力，一般Session会配合Cookie一起使用。</p>
<h3 id="怎么使用sessionhow">怎么使用Session?（How)</h3>
<h4 id="创建session">创建Session</h4>
<pre><code class="language-java">// Session是由容器自动创建的，我们可以在代码中直接获取Sesssion

HttpSession session = request.getSession();
</code></pre>
<h4 id="往session中存储数据">往Session中存储数据</h4>
<pre><code class="language-java">session.setAttribute();
</code></pre>
<h4 id="获取session中的数据">获取Session中的数据</h4>
<pre><code class="language-java">session.getAttribute();
</code></pre>
<h4 id="删除session中的数据">删除Session中的数据</h4>
<pre><code class="language-java">session.removeAttribute();
</code></pre>
<h4 id="修改session中的数据">修改Session中的数据</h4>
<pre><code class="language-java">// 修改Session中的数据和修改Cookie中的数据类似，都是覆盖添加

// 1. 获取要修改的数据
Object data = session.getAttribute(&quot;key&quot;);

// 2. 修改数据对应的属性
data.setXXX();

// 3. 将修改后的数据重新存入Session
session.setAttribute(&quot;key&quot;, data);

</code></pre>
<h4 id="强制让session失效">强制让Session失效</h4>
<pre><code class="language-java">session.invalidate();	//调用后session对象会失效，同时客户端Cookie中的JSESSIONID也会发生变化
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[集合总结]]></title>
        <id>https://klein-moretti.github.io/post/ji-he-zong-jie</id>
        <link href="https://klein-moretti.github.io/post/ji-he-zong-jie">
        </link>
        <updated>2017-06-25T02:07:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="集合框架">集合框架</h1>
<p>集合：简单的说，集合就是一种容器。</p>
<p>集合作为一种容器，里面可以存放内容，存放的每个内容称为是<strong>元素</strong>（element）。</p>
<p>在整个集合框架里一共有2个大类容器：Collection和Map</p>
<h2 id="collection容器interface">Collection容器（interface）</h2>
<p>Collection是元素类容器的根<strong>接口</strong>。</p>
<h4 id="什么是容器">什么是容器</h4>
<p>容器是一个用于存放东西的物件。</p>
<h4 id="容器应该具备什么功能呢什么样的物件叫容器">容器应该具备什么功能呢？（什么样的物件叫容器）</h4>
<ol>
<li>
<p>可以存东西</p>
<p><strong>add(E element)</strong>  //往容器里添加一个元素。元素可以是任意类型（整数，字符串，自定义类，容器）</p>
<p>addAll(Collection c) //往容器里添加多个元素。参数是一个容器，这个方法会把容器里的元素逐一添加进来</p>
</li>
<li>
<p>查看</p>
<p><strong>size()</strong>  //查看容器中包含多少元素</p>
<p><strong>contains(Object o)</strong> //查看是否包含某个元素</p>
<p>containsAll(Collection c) //查看是否包含某些元素</p>
<p>isEmpty() //是不是一个空容器</p>
</li>
<li>
<p>可以提取(删除)东西</p>
<p>clear()  //清空容器</p>
<p><strong>remove(Object o)</strong> //移除一个元素</p>
<p>removeAll(Collection c) //移除参数容器中包含的元素</p>
</li>
<li>
<p>其他</p>
<p>equals(Collection c) //判断是否个另外一个容器相等。</p>
<p>toArray() //把容器转换为数组</p>
</li>
</ol>
<h3 id="listinterface">List（interface）</h3>
<p>list的英文含义是：列表。</p>
<p>list用于定义什么是有序容器。有序容器是容器的一种。</p>
<p>List是一个接口，它有一个父接口Collection。<strong>List相比于Collection多了下标的概念</strong>。用标可以去访问元素。</p>
<p>围绕下标提供了一堆方法：</p>
<ol>
<li>
<p>添加元素</p>
<p><strong>add(int index, E element)</strong> //在指定的位置添加一个元素<br>
addAll(int index, Collection c) //在指定的位置添加多个元素</p>
<p>删除元素</p>
<p><strong>remove(int index)</strong> //移除指定位置的元素</p>
</li>
<li>
<p>获得子列表</p>
<p>subList(int fromIndex, int toIndex) //获取一个子列表  [formIndex, toIndex)</p>
</li>
<li>
<p>更新元素</p>
<p>set(int index, E element)// 把指定下标的元素更新为指定内容</p>
</li>
<li>
<p>获取元素的位置</p>
<p>indexOf(Object o) //获取指定元素的下标（正着查）</p>
<p>lastIndexOf(Object o)//获取指定元素的下标（倒着查）</p>
<p><strong>get(int index)</strong> //获取指定下标的元素</p>
</li>
</ol>
<h3 id="list的实现类">List的实现类</h3>
<h4 id="arraylist">ArrayList</h4>
<p>ArrayList是List的实现类。既然是实现类，说明ArrayList实现了List中定义的所有方法。</p>
<ol>
<li>
<p>如何创建一个ArrayList对象</p>
<p>ArrayList()   //创建一个初始容量为10的列表。列表里尚未存放任何元素。</p>
<p>ArrayList(int capacity) //创建一个指定初始容量的列表。列表里尚未存放任何元素</p>
<blockquote>
<p>初始容量: 列表刚创建时给定的容量。</p>
<p>Collection是个容器，这个容器与之前学过的数组不同，数组是定长的容器，不能减少容量也不能增加容量。但是Collection是一个变长的容器，空间不够的时候可以扩容。</p>
</blockquote>
<p>ArrayList(Collection c) //创建一个包含参数中全部元素的列表。</p>
</li>
<li>
<p>ArrayList的使用</p>
<p>增删改查（API参考 List）</p>
</li>
</ol>
<blockquote>
<p>在创建ArrayList的时候必须指定元素的类型。例如：ArrayList<String></p>
<p>一旦指定ArrayList存放什么类型的数据，以后取元素的时候，无需进行类型转换。</p>
</blockquote>
<ol start="3">
<li>
<p>遍历ArrayList</p>
<p>假定ArrayList内容如下：</p>
</li>
</ol>
<pre><code class="language-java">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
list.add(&quot;张三&quot;);
list.add(&quot;李四&quot;);
list.add(&quot;王五&quot;);
list.add(&quot;赵六&quot;);
</code></pre>
<p>遍历ArrayList的方法有很多，常用方式如下：</p>
<p>一、使用for循环遍历</p>
<pre><code class="language-java">for(int i = 0; i &lt; list.size(); i++){
  String str = list.get(i);
  System.out.println(str);
}
</code></pre>
<blockquote>
<p>使用list.size()获取元素个数， 从下标0开始循环到结束。通过list.get(i) 获取每个元素，达到遍历的效果。</p>
</blockquote>
<p><strong>二、使用迭代器遍历（推荐）</strong></p>
<pre><code class="language-java">Iterator&lt;String&gt; it = list.iterator();//获取迭代器（迭代器会包含list中所有的元素）
while(it.hasNext()){
    String str = it.next();//获取迭代器中的元素，next执行完，迭代器会指向下一个元素。
    System.out.println(str);
}
</code></pre>
<blockquote>
<p>Iterator是一个接口，规定了迭代器应该具有什么功能（hasNext(), next(), remove()）。</p>
<p>hasNext()方法：用于查看是否还有元素。如果迭代器中还有元素，返回true，如果没有元素了，返回false。</p>
<p>next()：获取当前迭代的元素，迭代器指向下一个元素。</p>
<p>remove(): 删除当前迭代到的元素。</p>
</blockquote>
<p>三、使用for..each遍历元素</p>
<pre><code class="language-java">for(String str : list){
    System.out.println(str);//str就是被遍历到的元素。
}
</code></pre>
<blockquote>
<p>for...each是for循环的增强版，有些语言叫for..in</p>
<p>for...each的本质是通过迭代器遍历元素。可通过XJad反编译工具反编译.class文件查看源码。</p>
</blockquote>
<h4 id="arraylist的优势和劣势">ArrayList的优势和劣势</h4>
<p>ArrayList的底层实现是数组，数组最大特点：数据的内存空间是连续的，所以根据下标查找元素是非常非常快。</p>
<p>弊端增加和删除慢，如果要删除下标为0的元素，实际上是通过循环，把下标为1的赋值给下标为0，把下标为2的赋值给下标为1的，以此类推，直到所有元素位置正确。</p>
<p>如果要在下标为0的位置添加一个元素，它也是通过循环实现的，最大下标的元素赋值给最大下标加1的位置，第2大的下标的元素赋值给最大下标，以此类推第0个元素赋值给第1个元素，新元素覆盖下标为0的元素。</p>
<h3 id="list的另外一个实现类-linkedlist">List的另外一个实现类 LinkedList</h3>
<p>LinkedList使用方式同ArrayList。</p>
<p>LinkedList与ArrayList不同，LinkedList底层靠的是双向链表在存储数据。</p>
<p>链表的特点：增删快，查询慢（需要遍历）。</p>
<h3 id="list的另外一个实现类-vector">List的另外一个实现类 Vector</h3>
<p>实现方式和ArrayList几乎一模一样，Vector所有的方法是线程安全的。在线程里，如果不同的线程在访问同一个List（Vector），不会出现数据紊乱（内部加了锁，一个方法执行的时候，其他的方法等待，执行完以后，其他方法才开始执行）。因为考虑的安全性，不断的加锁和解锁，所以效率很低，速度很慢。</p>
<h3 id="如何选择使用哪个list实现类">如何选择使用哪个List实现类？</h3>
<ol>
<li>
<p>看是否在多线程环境下访问。</p>
<p>是：Vector</p>
<p>否：转到2</p>
</li>
<li>
<p>看增删多还是查询多？</p>
<p>增删多：LinkedList</p>
<p>查询多：ArrayList</p>
<p>不知道：ArrayList</p>
</li>
</ol>
<p>List<Type> list = new   xxxx<Type>()<br>
;</p>
<h3 id="setinterface">Set(interface)</h3>
<p>set是一个接口，<strong>用于描述一个元素不重复的容器</strong>。set里面的重复元素只会出现一次。</p>
<p>首先set是一个容器，既然是容器，那么容器所应该具有的功能它都有。也就说Collection接口中定义的方法，Set里都要有。</p>
<p>通过查阅API，发现Set没有自己独有的方法，Set里所有的方法来自于Collection。</p>
<h3 id="set的实现类">Set的实现类</h3>
<h4 id="hashset-普通set">HashSet （普通set）</h4>
<p>HashSet的特点：</p>
<ol>
<li>不重复</li>
<li>无序</li>
</ol>
<blockquote>
<p>注意：如果要往HashSet中添加自定义类型的数据，你需要给自定义的类添加equals方法，HashSet在添加元素的时候，会拿现有元素逐一和要添加的元素比较（用equals比较），如果相等了，就不添加，比较一遍之后没有相等的，把元素加进来。</p>
</blockquote>
<h4 id="hashset的创建">HashSet的创建</h4>
<ol>
<li>
<p>HashSet() //创建一个空的Set，初始容量为16</p>
</li>
<li>
<p>HashSet(int capacity) //创建一个空的Set，初始容量为指定的容量。</p>
</li>
<li>
<p>HashSet(Collection c) //创建一set，初始内容是c中的元素（会去重）。</p>
</li>
</ol>
<p>HashSet的添加和删除元素API见Set</p>
<blockquote>
<p>HashSet没有获取元素的方法，也没有设置元素的方法。</p>
<p>如何取元素呢？---通过遍历来读取。</p>
</blockquote>
<p>思考？</p>
<p>能否使用for循环遍历Set？-----不能！因为没有下标</p>
<h4 id="hashset的遍历">HashSet的遍历</h4>
<p>假定有如下Set：</p>
<pre><code class="language-java">Set&lt;String&gt; s = new HashSet&lt;&gt;();
s.add(&quot;zhangsan&quot;);
s.add(&quot;lisi&quot;);
s.add(&quot;wangwu&quot;);
s.add(&quot;zhaoliu&quot;);
</code></pre>
<ol>
<li>
<p>使用for..each遍历</p>
<pre><code class="language-java">for(String str : s){
    System.out.println(str);//str就是我们set中每个元素
}
</code></pre>
</li>
<li>
<p>使用Iterator遍历</p>
<pre><code class="language-java">Iterator&lt;String&gt; it = s.iterator();
while(it.hasNext()){
  String str = it.next();
  System.out.println(str);
}
</code></pre>
</li>
</ol>
<h4 id="set另外一个实现类-linkedhashset">Set另外一个实现类 LinkedHashSet</h4>
<p>LinkedHashSet是一个有序的不重复的容器。</p>
<p>特点如下：</p>
<ol>
<li>有序（存放顺序有序）</li>
<li>不重复</li>
</ol>
<h3 id="小节">小节</h3>
<p>Collection是什么？</p>
<p>答：它是一个接口。用来描述容器应该具有哪些功能。（add,addAll,clear,remove,contains,size,iterator）</p>
<p>List是什么？</p>
<p>答：它是一个接口,这个接口继承了Colletion。用来描述一个有序的容器。有序指的是存放顺序。提供了下标的概念（index），围绕下标提供了一堆方法。（add(index,object),addAll(index,collection), remove(index),indexOf(object), lastIndexOf(object), get(index),set(index,object)）</p>
<p>List的实现类有哪些？</p>
<p>ArrayList：底层是数组（内存空间连续），查询快，增删慢。</p>
<p>LinkedList：底层是链表，增删快，查询慢。</p>
<p>Vector：线程安全。</p>
<p><strong>List的遍历方法：</strong></p>
<p>for循环</p>
<p>for each</p>
<p><strong>迭代器</strong></p>
<p>Set是什么？</p>
<p>答：set是一个接口，继承于Collection。用来描述不重复的容器。</p>
<p>Set的实现类有哪些？</p>
<p>HashSet：无序不重复。要求容器里的元素实现了equals方法。</p>
<p>LinkedHashSet：有序不重复。有序指的是存放顺序。也需要元素实现equals放法。</p>
<p>TreeSet：有序不重复。有序指的是内容有序。</p>
<h3 id="treeset-是一个set的实现类">TreeSet 是一个Set的实现类</h3>
<p>TreeSet是一个不重复的容器，而且内容有序。靠Comparable或者Comparator来实现比较，确定是否重复以及谁大谁小。</p>
<p>TreeSet有2大类创建方式：</p>
<ol>
<li>自然排序。 元素本身带有比较方法（本质是元素实现了Comparable接口）</li>
<li>比较器排序。元素本身不具备比较的能力，比较帮元素比较大小。</li>
</ol>
<p>TreeSet底层靠的二叉树来实现内容有序。小的元素放在树的左分支上，大的放在右分支上。读取元素时，TreeSet使用中序遍历的方式读取元素。</p>
<p>TreeSet添加元素以及删除元素和HashSet一样。</p>
<h3 id="小节-2">小节</h3>
<p>Collection描述一个容器</p>
<p>​	List：有序容器，可重复</p>
<p>​		ArrayList： 数组</p>
<p>​		LinkedList： 链表</p>
<p>​		Vector：数组</p>
<p>​	Set：不可重复，通常是无序的。</p>
<p>​		HashSet：普通集合</p>
<p>​		LinkedHashSet：存放顺序有序，不可重复</p>
<p>​		TreeSet：内容有序，不可重读</p>
<h2 id="map接口">Map（接口）</h2>
<p>Map是用来描述一个容器，用来描述一个键值对容器。</p>
<p>Map的特点：键不允许重复。</p>
<p>Map和Colletion是平级的。Map数据键值对接口中的根接口。</p>
<ol>
<li>
<p>添加元素到Map中</p>
<p><strong>put(key, value)</strong> //往Map中存放元素，如果Map中已经有这个key了，会覆盖。如果Map中没有这个key，会把这个键值对存入map</p>
<p>putAll(Map map) //把另外一个map中的元素全部添加到当前map中，如果有key已经存在了，会产生覆盖。</p>
</li>
<li>
<p>移除元素</p>
<p><strong>remove(key)</strong> //根据key移除对应的键值对。</p>
</li>
<li>
<p>修改元素</p>
<p>put(key, value) //如果Map中已经有这个key了，会覆盖. 如果没有就是添加</p>
</li>
<li>
<p>查看Map</p>
<p><strong>size()</strong> //查看里面有多少键值对</p>
<p>containsKey(key) //查看是否有某个key</p>
<p>containsValue(value) //查看是否有某个value</p>
<p><strong>get(key)</strong> //获取key对应的值。</p>
<p><strong>keySet()</strong> //获取所有的key</p>
<p>values() //获取所有的value</p>
<p><strong>entrySet</strong> //获取键值对集合</p>
</li>
</ol>
<h2 id="map的实现类">Map的实现类</h2>
<h3 id="hashmap">HashMap</h3>
<p>HashMap是一个普通的Map。</p>
<h4 id="创建hashmap">创建HashMap</h4>
<ol>
<li>HashMap()  创建一个空的Map，初始容量是16， 加载因子是0.75</li>
<li>HashMap(int capacity) 创建一个空的Map， 初始容量为指定的容量，加载因子是0.75</li>
<li>HashMap(int capacity, float loadFactor) 创建一个空的Map，初始容量和加载因子由参数指定。</li>
<li>HashMap(Map map) 创建一个包含指定键值对的Map。</li>
</ol>
<h3 id="hashmap的使用">HashMap的使用</h3>
<p>增删改查 见Map的API</p>
<h3 id="map的遍历">Map的遍历</h3>
<p>假定有如下Map：</p>
<pre><code class="language-java">Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
map.put(&quot;one&quot;, 100);
map.put(&quot;two&quot;, 88);
map.put(&quot;three&quot;, 96);
map.put(&quot;four&quot;, 88);
</code></pre>
<p>for each遍历</p>
<pre><code class="language-java">Set&lt;String&gt; keys = map.keySet();
for(String key : keys) {
	System.out.println(key+ &quot;----&quot; + map.get(key));
}
</code></pre>
<p>使用迭代器遍历</p>
<pre><code class="language-java">Iterator&lt;String&gt; it = keys.iterator();
while(it.hasNext()) {
	String key = it.next();
	int value = map.get(key);
	System.out.println(key + &quot;===&quot; + value);
}
</code></pre>
<p>for each遍历键值对</p>
<pre><code class="language-java">Set&lt;Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();
for(Entry&lt;String, Integer&gt; e : entries) {
	System.out.println(e.getKey()+ &quot;__&quot;+ e.getValue());
}
</code></pre>
<blockquote>
<p>Entry是专门服务于Map的类。它代表键值对对象，内部含有键和值。如果要取出键和值，使用getKey()以及getValue().</p>
<p>Entry本质上Map中内部类。</p>
</blockquote>
<p>迭代器遍历键值对</p>
<pre><code class="language-java">Iterator&lt;Entry&lt;String,Integer&gt;&gt; it2 = entries.iterator();
while(it2.hasNext()) {
	Entry&lt;String, Integer&gt; e = it2.next();
	System.out.println(e.getKey()+&quot;  &quot;+e.getValue());
}
</code></pre>
<h4 id="linkedhashmap">LinkedHashMap</h4>
<p>存放顺序有序的Map。特点：存放顺序有序，键不能重复。</p>
<h4 id="treemap">TreeMap</h4>
<p>key的内容有序的Map。特点：key的内容有序，键不能重复。</p>
<h4 id="hashtable">HashTable</h4>
<p>它与HashMap非常类似，只不过HashTable是线程安全的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面向对象   继承, super, 重写, 访问控制]]></title>
        <id>https://klein-moretti.github.io/post/mian-xiang-dui-xiang-ji-cheng-super-chong-xie-fang-wen-kong-zhi</id>
        <link href="https://klein-moretti.github.io/post/mian-xiang-dui-xiang-ji-cheng-super-chong-xie-fang-wen-kong-zhi">
        </link>
        <updated>2017-02-10T10:38:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一什么是继承">一,什么是继承,</h2>
<p>​	生活中的继承: 子承父业</p>
<h2 id="二为什么要使用继承">二,为什么要使用继承</h2>
<p>​	多个类中存在相同的属性和方法时, 将这些内容抽取到单独的一个类中,那么多个类无需再定义这些属性和行为, 只需从这个类继承即可, 用来提高代码的复用性, 以及可维护性.</p>
<h2 id="三java中继承的语法格式">三,Java中继承的语法格式</h2>
<p>​	Java中使用extends关键字 实现一个类从另外一个类继承, 那么extends关键字的含义是”扩展”.</p>
<pre><code class="language-java">class A extends class B{

}
</code></pre>
<p>A从B继承, A是B的子类, 派生类,SubClass, B是A的父类, 也叫做基类,超类,SuperClass</p>
<p>​    通过继承, 子类可以继承父类中所有的属性和方法.(私有的方法及构造器除外)</p>
<h2 id="四继承的注意事项">四,继承的注意事项.</h2>
<ol>
<li>Java祖宗类: java.lang.Object.,所有的类都是源自于它.</li>
<li>子类不能单纯的为了获得父类的东西而使用继承, 使用继承时要能够被描述成所属关系is a. 比如学生是个人, 老师是个人.</li>
<li>JAVA里面只支持单继承, 不支持多继承, 支持多层继承(子类还可以再有子类).</li>
</ol>
<h2 id="五-继承之后属性的特点">五, 继承之后属性的特点</h2>
<ol>
<li>如果类中出现了和父类同名的属性的时候,创建子类对象,调用该属性, 使用的是子类的</li>
<li>如果需要使用父类的,可以使用super关键字, 使用super可以访问父类的属性,方法,和构造器, super.属性, super.方法, super(...)构造器</li>
</ol>
<pre><code>PS:super的使用方法和this一模一样, super.属性, super.方法, super()调用父类构造器, this使用在本类中,代表当前对象. super使用在子类中, 访问父类的成员, super仅仅是个关键字,不是引用.
</code></pre>
<ol start="3">
<li>子类从父类继承之后, 子类可以获得父类所有的属性和方法, (私有方法和构造器除外),父类修饰成private的属性, 子类不能直接访问, 但可以通过公共的set/get方法间接访问</li>
</ol>
<h2 id="六-方法重写override">六, 方法重写Override</h2>
<h3 id="1为什么要使用方法重写">1.为什么要使用方法重写</h3>
<ol>
<li>当父类方法实现不能够满足子类需求时, 子类可以对父类方法进行重写</li>
<li>因为子类是父类的扩展, 当子类对父类方法进行重写后, 需要保留父类方法实现, 可以在重写方法中, 使用super.调用父类方法实现.</li>
</ol>
<h3 id="2方法重写注意事项">2.方法重写注意事项</h3>
<ol>
<li>必须要有继承</li>
<li>方法名, 参数列表必须一致.</li>
<li>访问修饰符可以不一样,但是子类的访问修饰符不能够小于父类的访问修饰符. 如,父类是默认, 子类是public</li>
<li>返回值可以不一样, 但是子类重写方法的” 返回值类型”,必须是” 父类返回值类型”的子类</li>
<li>通常重写方法需要加上@Override注解, 做重写方法检查</li>
</ol>
<h2 id="七方法重载和方法重写的区别">七:方法重载和方法重写的区别</h2>
<p><strong>方法重载:</strong></p>
<p>1.方法名相同</p>
<p>2.参数列表不同(参数个数, 参数类型)</p>
<p>3.与返回值类型无关</p>
<p><strong>方法重写同6-2</strong></p>
<h2 id="八继承后构造器的特点">八,继承后构造器的特点</h2>
<p>1.当子类继承父类后, 子类中所有的构造器的第一句,都有一个隐式的:super().</p>
<p>super()的作用, 是调用父类无参的构造器.</p>
<p>super()的目的, 当子类继承父类后,继承了父类所有的属性和方法, 因此,子类需要知道父类是如何为对象进行初始化的.</p>
<p>2.如果父类中没有显式定义无参构造, 只给了有参构造, 那么子类的构造器中,就不能使用super(),</p>
<p><strong>解决方法:</strong></p>
<p>1.父类显式提供一个无参构造</p>
<p>2.子类构造器中, 显式调用父类有参构造, 如果子类显式调用了父类的有参构造super(参数),  子类构造隐式的super()将不再提供.</p>
<p>3.子类所有的构造器里, 默认都有一个隐式的super().</p>
<p>4.super() 必须出现在当前构造器中的首行 ,</p>
<p>5.super() 和this() 不能同时出现(指的是super和this调用构造方法)</p>
<h2 id="九访问控制修饰符">九:访问控制修饰符</h2>
<table>
<thead>
<tr>
<th>权限修饰符</th>
<th>本类</th>
<th>同一个包下</th>
<th>不同包下</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>子类</td>
<td>无关类</td>
<td>子类</td>
<td>无关类</td>
<td></td>
<td></td>
</tr>
<tr>
<td>private(私有)</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>默认(不写)</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected(受保护的)</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td></td>
</tr>
<tr>
<td>public(公共的)</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody>
</table>
<p><strong>public:</strong> 公共的, 可用于修饰属性,方法,类, 可以在任何地方访问.</p>
<p><strong>protected:</strong> 受保护的, 可用于修饰属性,方法, 只能在本类中, 本包中, 子类中使用</p>
<p><strong>default:</strong> 默认的(缺省的), 可用于修饰属性,方法,和类. 只能在本类中, 本包中使用 (并不是关键字, 什么都不写就是default)</p>
<p><strong>private:</strong> 私有的, 可用于修饰属性, 方法, 只能在本类中使用.</p>
]]></content>
    </entry>
</feed>