<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://klein-moretti.github.io</id>
    <title>Gridea</title>
    <updated>2019-12-11T12:28:20.344Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://klein-moretti.github.io"/>
    <link rel="self" href="https://klein-moretti.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://klein-moretti.github.io/images/avatar.png</logo>
    <icon>https://klein-moretti.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[Mybatis框架总结]]></title>
        <id>https://klein-moretti.github.io/post/mybatis-kuang-jia-zong-jie</id>
        <link href="https://klein-moretti.github.io/post/mybatis-kuang-jia-zong-jie">
        </link>
        <updated>2018-12-06T12:22:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="mybatis框架">Mybatis框架</h1>
<h2 id="mybatis介绍">Mybatis介绍</h2>
<h2 id="mybatis简单使用">Mybatis简单使用</h2>
<ol>
<li>
<p>初始化SqlSessionFactory对象</p>
<p>SqlSessionFactory对象需要从一个核心配置文件中构建，因此我们创建SqlSessionFactory对象之前需要先配置一个Mybatis核心配置文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;!-- 引入外部properties文件,路径从类路径的根目录开始 --&gt;
    &lt;properties resource=&quot;jdbc.properties&quot; /&gt;

    &lt;settings&gt;
        &lt;!-- 开启将数据库中下划线连接的字段自动映射为Java的小驼峰命名 --&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;

    &lt;!-- 定义类型别名，在xxxMapper.xml文件中就可以用别名代替很长的类名 --&gt;
    &lt;typeAliases&gt;
        
            &lt;!-- 单个类配置别名 --&gt;
&lt;!--        &lt;typeAlias type=&quot;com.lanou3g.mybatis.bean.User&quot; alias=&quot;User&quot; /&gt;--&gt;
        
            &lt;!-- 统一配置某个包下所有类的别名, 会使用 Bean 的首字母小写的类名来作为它的别名。 --&gt;
        &lt;package name=&quot;com.lanou3g.mybatis.bean&quot; /&gt;
    &lt;/typeAliases&gt;


    &lt;!-- 配置不同环境的参数 --&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;!-- 开发环境数据库、事务配置 --&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;!-- 事务管理使用JDBC的事务 --&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;!-- 配置开发环境数据源 --&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;${jdbc.user}&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
                &lt;!-- 将所有driver.开头的参数，附加到url属性的值后面上 --&gt;
                &lt;property name=&quot;driver.characterEncoding&quot; value=&quot;utf8&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;

    &lt;!-- 将mapper SQL映射文件包含进来 --&gt;
    &lt;mappers&gt;
        &lt;!-- 将通过XML方式配置的mapper引入进来 --&gt;
        &lt;mapper resource=&quot;mapper/userMapper.xml&quot;/&gt;
        &lt;!-- 将通过注解方式配置的mapper引入进来 --&gt;
&lt;!--        &lt;mapper class=&quot;com.lanou3g.mybatis.mapper.UserMapper&quot; /&gt;--&gt;

        &lt;!-- 将com.lanou3g.mybatis.mapper包下所有通过注解方式配置的mapper引入进来 --&gt;
&lt;!--        &lt;package name=&quot;com.lanou3g.mybatis.mapper&quot;/&gt;--&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<p>构建对象</p>
<pre><code class="language-java">// 1. 初始化mybatis配置
String confPath = &quot;mybatis_conf.xml&quot;;
InputStream in = Resources.getResourceAsStream(confPath);

// 2. 构建SqlSessionFactory对象
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in);
</code></pre>
</li>
<li>
<p>创建SqlSession对象</p>
<p>通过上一步的SqlSessionFactory对象可以获取到负责执行SQL语句的SqlSession对象</p>
<pre><code class="language-java">// 3. 获取SqlSession对象，默认事务不自动提交
// SqlSession sqlSession = sqlSessionFactory.openSession();
// 获取一个自动提交事务的sqlSession
SqlSession sqlSession = sqlSessionFactory.openSession(true);
</code></pre>
</li>
<li>
<p>用SqlSession对象从Mybatis中获取Mapper接口的实现类</p>
<pre><code class="language-java">// 4. 获取Mapper
UserMapper mapper = sqlSession.getMapper(UserMapper.class);
</code></pre>
</li>
<li>
<p>编写Mapper对象的xml配置文件</p>
<p>XML格式的Mapper配置文件类似于接口的实现类，它指定了具体要执行的SQL语句，以及结果集如何映射。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.lanou3g.mybatis.mapper.UserMapper&quot;&gt;
    &lt;select id=&quot;queryAllUser&quot; resultType=&quot;user&quot;&gt;
        select * from user
     &lt;/select&gt;

    &lt;insert id=&quot;insertUser&quot;&gt;
      insert into user (username,nick_name,email)
      values (#{username},#{nickName},#{email})
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
</li>
</ol>
<h2 id="深入了解mybatis">深入了解Mybatis</h2>
<h3 id="主要组件">主要组件</h3>
<h4 id="核心配置文件">核心配置文件</h4>
<p>核心配置文件是Mybatis的入口，它里面可以配置mybatis的具体参数、数据源、类型别名、关联映射文件等。</p>
<p>具体的参数配置说明参见：</p>
<p><a href="https://mybatis.org/mybatis-3/zh/configuration.html">Mybatis3核心配置文件官方说明</a></p>
<h4 id="sqlsessionfactory">SqlSessionFactory</h4>
<p>一个SqlSessionFactory只能连接一个数据库实例，如果需要连接多个数据库，需要构建多个SqlSessionFactory对象。</p>
<p>在构建SqlSesssionFactory时可以指定environment的id，表示使用指定的数据源来构建factory对象</p>
<pre><code class="language-java">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in, &quot;dev&quot;);
</code></pre>
<h4 id="sqlsession">SqlSession</h4>
<p>一个SqlSession对象代表一次到数据的会话，该对象有一下功能：</p>
<ul>
<li>获取Mapper实现类</li>
<li>管理事务操作</li>
</ul>
<blockquote>
<p>注意： SqlSession对象是非线程安全的，在多线程环境下，建议不要作为类的实例属性来用。</p>
</blockquote>
<h4 id="mapper">Mapper</h4>
<ul>
<li>
<p>Mapper接口类</p>
<p>定义了增删盖查的方法。注意，必须是接口类型，而且方法只需要定义就可以了。</p>
</li>
<li>
<p>Mapper配置文件</p>
<p>Mapper配置文件中就是负责实现接口中的方法，它定义了具体要执行什么SQL语句，如何映射结果集。</p>
<ul>
<li>配置文件中select、delete、update、insert标签的id必须是对应接口中的方法名。</li>
<li>mapper文件的namespace属性需要对应Mapper接口的完全类型限定名。</li>
</ul>
</li>
</ul>
<h3 id="深入mybatis核心配置文件">深入Mybatis核心配置文件</h3>
<p>具体的参数配置说明参见：</p>
<p><a href="https://mybatis.org/mybatis-3/zh/configuration.html">Mybatis3核心配置文件官方说明</a></p>
<h3 id="深入mybatis映射配置文件">深入Mybatis映射配置文件</h3>
<h4 id="crud语句定义">CRUD语句定义</h4>
<h5 id="查询语句">查询语句</h5>
<p>接口中</p>
<pre><code class="language-java">List&lt;User&gt; queryAllUser();

User queryUserById(Integer id);
</code></pre>
<p>xml配置文件中</p>
<pre><code class="language-xml">&lt;select id=&quot;queryAllUser&quot; resultType=&quot;user&quot;&gt;
    select * from user
&lt;/select&gt;

&lt;select id=&quot;queryUserById&quot; resultType=&quot;user&quot;&gt;
    select * from user where id = #{id}
&lt;/select&gt;
</code></pre>
<h5 id="插入语句">插入语句</h5>
<h6 id="普通插入语句">普通插入语句</h6>
<p>接口中</p>
<pre><code class="language-java">int insertUser(User user);
</code></pre>
<p>xml配置文件中</p>
<pre><code class="language-xml">&lt;insert id=&quot;insertUser&quot;&gt;
    insert into user (username,nick_name,email)
    values (#{username},#{nickName},#{email})
&lt;/insert&gt;
</code></pre>
<h6 id="如何返回数据库自增的id">如何返回数据库自增的ID</h6>
<pre><code class="language-xml">&lt;!-- 给insert语句添加useGeneratedKeys、keyProperty后，mybatis会将自增的id值直接赋值到传进来的user对象的id属性上
        useGeneratedKeys: 指定需要获取数据库自增的id
        keyProperty: 指定自增地段的名称
     --&gt;
&lt;insert id=&quot;insertUser&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
    insert into user (username,nick_name,email)
    values (#{username},#{nickName},#{email})
&lt;/insert&gt;
</code></pre>
<h5 id="删除语句">删除语句</h5>
<p>接口中</p>
<pre><code class="language-java">void deleteUserById(Integer id);
</code></pre>
<p>XML配置中</p>
<pre><code class="language-xml">&lt;delete id=&quot;deleteUserById&quot;&gt;
    delete from user where id = #{id}
&lt;/delete&gt;
</code></pre>
<h5 id="更新语句">更新语句</h5>
<p>接口中</p>
<pre><code class="language-java">void updateUser(User user);
</code></pre>
<p>XML配置中</p>
<pre><code class="language-xml">&lt;update id=&quot;updateUser&quot;&gt;
    update user set password = #{password} where id = #{id}
&lt;/update&gt;
</code></pre>
<h4 id="接口中的参数如果传递到sql中">接口中的参数如果传递到SQL中</h4>
<h5 id="简单类型参数">简单类型参数</h5>
<p>接口中：</p>
<pre><code class="language-java">void deleteUserById(Integer id);
</code></pre>
<p>xml配置文件中：</p>
<pre><code class="language-xml">&lt;delete id=&quot;deleteUserById&quot;&gt;
    delete from user where id = #{id}
&lt;/delete&gt;
</code></pre>
<h5 id="引用类型参数">引用类型参数</h5>
<p>接口中：</p>
<pre><code class="language-java">int insertUser(User user);
</code></pre>
<p>xml配置文件中：</p>
<pre><code class="language-xml">&lt;!-- 给insert语句添加useGeneratedKeys、keyProperty后，mybatis会将自增的id值直接赋值到传进来的user对象的id属性上
        useGeneratedKeys: 指定需要获取数据库自增的id
        keyProperty: 指定自增地段的名称
     --&gt;
&lt;insert id=&quot;insertUser&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
    insert into user (username,nick_name,email)
    values (#{username},#{nickName},#{email})
&lt;/insert&gt;
</code></pre>
<h5 id="当接口中参数和xml配置取值时名称不一样时">当接口中参数和XML配置取值时名称不一样时</h5>
<p>在接口中的参数前加注解</p>
<pre><code class="language-java">User queryUserById(@Param(&quot;id&quot;) Integer xxxxxxxId);
</code></pre>
<p>在XML中取值时用注解指定的名称</p>
<pre><code class="language-xml">&lt;select id=&quot;queryUserById&quot; resultType=&quot;user&quot;&gt;
    select * from user where id = #{id}
&lt;/select&gt;
</code></pre>
<h5 id="与的区别">#{}与${}的区别</h5>
<ul>
<li>它俩都可以获取接口调用中传递过来的参数</li>
<li>#{}会将参数作为占位符，使用预编译语句(PreparedStatement)执行</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow></mrow><mi mathvariant="normal">会</mi><mi mathvariant="normal">直</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">实</mi><mi mathvariant="normal">际</mi><mi mathvariant="normal">参</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">替</mi><mi mathvariant="normal">换</mi></mrow><annotation encoding="application/x-tex">{}会直接用实际参数替换</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord"></span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">直</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">际</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">替</span><span class="mord cjk_fallback">换</span></span></span></span>{}， 参数可以作为SQL的一部分。</li>
</ul>
<p>比如，要实现下面的效果：</p>
<p>Java代码</p>
<pre><code class="language-java">List&lt;User&gt; queryAllUserOrderBy(String order);

// 调用：
mapper.queryAllUserOrderBy(&quot;last_login_time&quot;);
</code></pre>
<p>XML配置：</p>
<pre><code class="language-xml">&lt;select id=&quot;queryAllUserOrderBy&quot; resultMap=&quot;userMap&quot;&gt;
    select * from user order by ${order} desc;
&lt;/select&gt;
</code></pre>
<p>如果上面使用#{order}取获取参数，最终执行的SQL会是这样：</p>
<pre><code>==&gt;  Preparing: select * from user order by ? desc; 
==&gt; Parameters: last_login_time(String)
</code></pre>
<p>无法实现排序效果</p>
<p>如果使用${order}来取参数，最终执行SQL：</p>
<pre><code>==&gt;  Preparing: select * from user order by last_login_time desc; 
==&gt; Parameters: 
</code></pre>
<p>可以实现排序效果</p>
<h4 id="结果集如何映射">结果集如何映射</h4>
<h5 id="resulttype方式">ResultType方式</h5>
<p>ResultType方式适用于数据库结果集可以直接映射成一个Java类的情况</p>
<p>Java实体类：</p>
<pre><code class="language-java">@Getter
@Setter
@ToString
public class User {
    private Integer id;
    private String username;
    private String nickName;
    private String password;
    private String email;
    private Timestamp lastLoginTime;
}
</code></pre>
<p>使用方法：</p>
<pre><code class="language-xml">&lt;select id=&quot;queryAllUser&quot; resultType=&quot;com.lanou3g.bean.User&quot;&gt;
    select * from user
&lt;/select&gt;
</code></pre>
<h5 id="resultmap方式">ResultMap方式</h5>
<p>ResultMap方式适用于复杂的结果集映射，比如数据库返回的结果集中的列名和JavaBean无法一一对应，或者对象间存在一对一、一对多关联映射时。</p>
<h6 id="解决数据库列名与java类中属性名不一致的映射问题">解决数据库列名与Java类中属性名不一致的映射问题</h6>
<pre><code class="language-xml">&lt;mapper&gt;
    ...
    &lt;resultMap id=&quot;userMap&quot; type=&quot;user&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
        &lt;result property=&quot;username&quot; column=&quot;username&quot; /&gt;
        &lt;result property=&quot;lastLoginttime&quot; column=&quot;last_login_time&quot; /&gt;
        &lt;result property=&quot;email&quot; column=&quot;email&quot; /&gt;
        &lt;result property=&quot;nickName&quot; column=&quot;nick_name&quot; /&gt;
    &lt;/resultMap&gt;
    ...
&lt;/mapper&gt;
</code></pre>
<p>在查询语句中将resultType换成resultMap</p>
<pre><code class="language-xml">&lt;select id=&quot;queryAllUser&quot; resultMap=&quot;userMap&quot;&gt;
    select * from user
&lt;/select&gt;
</code></pre>
<blockquote>
<p>其实，如果遇到单纯字段名和属性名不对应的情况，使用别名的方式更简单</p>
</blockquote>
<h6 id="解决一对一映射查询问题">解决一对一映射查询问题</h6>
<p>1.先创建bean类</p>
<pre><code class="language-java">@Setter
@Getter
@ToString
public class Teacher {
    private Integer id;
    private String name;
    private Grade grade;
}
</code></pre>
<p>2.创建mapper接口</p>
<pre><code class="language-java">public interface TeacherMapper {
    Teacher findTeacherById(Integer id);
}
</code></pre>
<p>3.创建mybatis的配置文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;properties resource=&quot;jdbc.properties&quot;/&gt;
    
    &lt;settings&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;

    &lt;typeAliases&gt;
        &lt;!-- 统一配置某个包下所有类的别名, 会使用 Bean 的首字母小写的类名来作为它的别名。 --&gt;
        &lt;package name=&quot;com.su.mybatis.bean&quot;/&gt;
    &lt;/typeAliases&gt;

    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;

            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;${jdbc.user}&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
                &lt;property name=&quot;driver.characterEncoding&quot; value=&quot;utf8&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;

    &lt;mappers&gt;
        &lt;mapper resource=&quot;mapper/teacherMapper.xml&quot; /&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<p>4.在resources里创建mapper.xml文件</p>
<p>MyBatis中使用association标签来解决一对一的关联查询，association标签可用的属性如下：</p>
<ul>
<li>property:对象属性的名称</li>
<li>javaType:对象属性的类型</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.su.mybatis.mapper.TeacherMapper&quot;&gt;
    
    &lt;resultMap id=&quot;teacherMap&quot; type=&quot;teacher&quot;&gt;
        &lt;id column=&quot;tid&quot; property=&quot;id&quot; /&gt;
        &lt;result column=&quot;tname&quot; property=&quot;name&quot; /&gt;
        &lt;!-- 一对一映射关系 --&gt;
        &lt;association property=&quot;grade&quot; javaType=&quot;grade&quot; resultMap=&quot;gradeMap&quot; /&gt;
    &lt;/resultMap&gt;

    &lt;resultMap id=&quot;gradeMap&quot; type=&quot;grade&quot;&gt;
       &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt;
        &lt;result column=&quot;name&quot; property=&quot;name&quot; /&gt;
       &lt;result column=&quot;tid&quot; property=&quot;tId&quot; /&gt;
    &lt;/resultMap&gt;
    &lt;!-- 此语句只处理了一对一，也就是说只关联查询了Teacher里面的grade属性 --&gt;
    &lt;select id=&quot;findTeacherById&quot; resultMap=&quot;teacherMap&quot; &gt;
        SELECT
            t.id tid,
            t.`name` tname,
            g.id grade_id,
            g.`name` grade_name
        FROM
           teacher t
        LEFT JOIN grade g ON t.id = g.t_id
        WHERE
            t.id = #{id}
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>5.使用</p>
<pre><code class="language-java">public class TestMain {
    public static void main(String[] args) throws IOException {
        String confPath = &quot;mybatis_conf.xml&quot;;
        InputStream in = Resources.getResourceAsStream(confPath);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in);
        SqlSession sqlSession = sqlSessionFactory.openSession();
        TeacherMapper mapper = sqlSession.getMapper(TeacherMapper.class);
        Teacher li = mapper.findTeacherById(1);
        System.out.println(li);
        System.out.println(li.getName());
    }
}
</code></pre>
<h6 id="解决一对多映射查询问题">解决一对多映射查询问题</h6>
<p>1.先创建bean类</p>
<pre><code class="language-java">@Setter
@Getter
@ToString
public class Teacher {
    private Integer id;
    private String name;
    private List&lt;Student&gt; students;
}

@Setter
@Getter
@ToString
public class Student {
    private Integer id;
    private Integer tId;
    private String name;
}
</code></pre>
<p>2.创建mapper接口</p>
<pre><code class="language-java">public interface TeacherMapper {
    Teacher findTeacherById(Integer id);
}
</code></pre>
<p>3.创建mybatis的配置文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;

    &lt;properties resource=&quot;jdbc.properties&quot;/&gt;
    
    &lt;settings&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;

    &lt;typeAliases&gt;
        &lt;package name=&quot;com.su.mybatis.bean&quot;/&gt;
    &lt;/typeAliases&gt;

    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;${jdbc.user}&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; 
                &lt;property name=&quot;driver.characterEncoding&quot; value=&quot;utf8&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;

    &lt;mappers&gt;
        &lt;mapper resource=&quot;mapper/teacherMapper.xml&quot; /&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<p>4.在resources里创建mapper.xml文件</p>
<p>MyBatis中使用collection标签来解决一对多的关联查询，collection标签可用的属性如下：</p>
<ul>
<li>property:指的是集合属性的值</li>
<li>ofType:指的是集合中元素的类型</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.su.mybatis.mapper.TeacherMapper&quot;&gt;
    
    &lt;resultMap id=&quot;teacherMap&quot; type=&quot;teacher&quot;&gt;
        &lt;id column=&quot;tid&quot; property=&quot;id&quot; /&gt;
        &lt;result column=&quot;tname&quot; property=&quot;name&quot; /&gt;
        &lt;!-- 一对多映射关系 --&gt;
        &lt;collection property=&quot;students&quot; ofType=&quot;student&quot; resultMap=&quot;studentMap&quot; columnPrefix=&quot;student_&quot; /&gt;
    &lt;/resultMap&gt;
 
    &lt;resultMap id=&quot;studentMap&quot; type=&quot;student&quot;&gt;
        &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt;
        &lt;result column=&quot;name&quot; property=&quot;name&quot; /&gt;
        &lt;result column=&quot;tid&quot; property=&quot;tId&quot;/&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;findTeacherById&quot; resultMap=&quot;teacherMap&quot; useCache=&quot;true&quot; &gt;
        SELECT
            t.id tid,
            t.`name` tname,
            s.id student_id,
            s.`name` student_name,
            t.id student_tid
        FROM
           teacher t
        left join student s on s.t_id = t.id
        WHERE
            t.id = #{id}
            
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>5.使用</p>
<pre><code class="language-java">public class TestMain {
    public static void main(String[] args) throws IOException {
        String confPath = &quot;mybatis_conf.xml&quot;;
        InputStream in = Resources.getResourceAsStream(confPath);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in);
        SqlSession sqlSession = sqlSessionFactory.openSession();
        TeacherMapper mapper = sqlSession.getMapper(TeacherMapper.class);
        Teacher li = mapper.findTeacherById(1);
        System.out.println(li);
        System.out.println(li.getName());
    }
}
</code></pre>
<h4 id="动态sql">动态SQL</h4>
<p>使用动态sql</p>
<p>1.创建bean类</p>
<p>2.创建mapper接口</p>
<p>3.创建mapper.xml文件</p>
<p>4.配置mybatis配置文件</p>
<p>5.使用</p>
<h5 id="条件分支sql">条件分支SQL</h5>
<ul>
<li>
<p>if</p>
<p>1.在mapper接口写入抽象方法</p>
<p>2.在mapper.xml文件中写入:</p>
<pre><code class="language-xml">&lt;!--id名与mapper接口中方法名一致--&gt;
&lt;select id=&quot;queryAllUserByCondition&quot; resultType=&quot;user&quot;&gt;
        SELECT * FROM `user` WHERE status = 1
        &lt;if test=&quot;password != null&quot;&gt;
            AND password like #{password}
        &lt;/if&gt;
        &lt;if test=&quot;createtime != null and username != null&quot;&gt;
            AND username like #{username}
        &lt;/if&gt;
    &lt;/select&gt;
</code></pre>
<blockquote>
<p>如果我们的state字段也是动态拼接的，那这里就有问题了，比如我三个条件都没有时，拼出来的sql语句就是<code>SELECT * FROM BLOG WHERE</code>显然是无法执行的，这就要用到我们的<code>where</code>标签</p>
</blockquote>
</li>
<li>
<p>choose&amp;when&amp;otherwise</p>
<p>1.在mapper接口写入抽象方法</p>
<p>2.在mapper.xml文件中写入:</p>
<pre><code class="language-xml">&lt;select id=&quot;queryAllUserByCondition&quot; resultType=&quot;user&quot;&gt;
        SELECT * from `user`
        &lt;where&gt;
            &lt;choose&gt;
                &lt;when test=&quot;username != null&quot;&gt;
                    username like #{username}
                &lt;/when&gt;
                &lt;when test=&quot;status != null&quot;&gt;
                    and `status` = #{status};
                &lt;/when&gt;
                &lt;otherwise&gt;
                    and 1 = 1
                &lt;/otherwise&gt;
            &lt;/choose&gt;
        &lt;/where&gt;
 &lt;/select&gt;
</code></pre>
</li>
</ul>
<blockquote>
<p>有时我们不想应用到所有的条件语句，而只想从中择其一项。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句</p>
</blockquote>
<h5 id="循环sql">循环SQL</h5>
<ul>
<li>
<p>forEach</p>
<blockquote>
<p>使用场景:对一个集合进行遍历</p>
</blockquote>
<p>1.在mapper接口写入抽象方法</p>
<p>2.在mapper.xml文件中写入:</p>
<pre><code class="language-xml">   &lt;select id=&quot;queryUserByIn&quot; resultType=&quot;com.su.mybatis.bean.User&quot;&gt;
        select * from user where id
        &lt;foreach collection=&quot;list&quot; item=&quot;val&quot; open=&quot;in (&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt;
            #{val}
        &lt;/foreach&gt;
    &lt;/select&gt;
</code></pre>
</li>
</ul>
<h5 id="其他特殊sql">其他特殊SQL</h5>
<ul>
<li>
<p>where</p>
<p>当我们拼接动态SQL时，如果一个查询条件都没有，那我们就不需要where子句，而如果有至少一个条件我们就需要where子句。这样，我们就需要做个判断，而mybatis里的标签就省去了我们自己做这个判断。 使用示例:</p>
<pre><code class="language-xml">&lt;select id=&quot;queryAllUserByCondition&quot; resultType=&quot;user&quot;&gt;
        SELECT * from `user`
        &lt;where&gt;
            &lt;if test=&quot;username != null&quot;&gt;
                username like #{username}
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and `status` = #{status};
            &lt;/if&gt;
        &lt;/where&gt;
&lt;/select&gt;
</code></pre>
</li>
<li>
<p>set</p>
<p>set 元素会动态前置 SET 关键字，同时也会删掉无关的逗号(如：语句最后的逗号)<br>
使用示例：</p>
<pre><code class="language-xml">&lt;update id=&quot;updateAuthorIfNecessary&quot;&gt;
  update Author
    &lt;set&gt;
      &lt;if test=&quot;username != null&quot;&gt;username=#{username},&lt;/if&gt;
      &lt;if test=&quot;password != null&quot;&gt;password=#{password},&lt;/if&gt;
      &lt;if test=&quot;email != null&quot;&gt;email=#{email},&lt;/if&gt;
      &lt;if test=&quot;bio != null&quot;&gt;bio=#{bio}&lt;/if&gt;
    &lt;/set&gt;
  where id=#{id}
&lt;/update&gt;
</code></pre>
</li>
<li>
<p>trim</p>
<p>trim标签可以常用属性有：</p>
<ul>
<li>
<p><code>prefix</code>: 添加指定前缀</p>
</li>
<li>
<p><code>prefixOverrides</code>: 删除指定前缀</p>
</li>
<li>
<p><code>suffixOverrides</code>: 删除指定后缀<br>
示例一：用标签实现标签功能</p>
<pre><code class="language-xml">&lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt;
  ...
&lt;/trim&gt;
</code></pre>
<blockquote>
<p>prefixOverrides的作用是移除字符串开头的内容中所有指定在 prefixOverrides 属性中的内容，并且插入 prefix 属性中指定的内容</p>
</blockquote>
<p>示例二:</p>
<pre><code class="language-xml">&lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt;
  ...
&lt;/trim&gt;
</code></pre>
<blockquote>
<p>注意这里我们删去的是后缀值，同时添加了前缀值。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="批量插入">批量插入</h4>
<h5 id="通过foreach动态sql方式">通过forEach动态SQL方式</h5>
<h6 id="实现原理">实现原理</h6>
<p>forEach批量插入的原理是直接通过forEach动态标签，根据传过来的参数数量动态生成一个很长的SQL语句。一个语句就是一次批量插入。</p>
<p>语句形如：</p>
<pre><code class="language-sql">insert into user (username, age) values
('张三', 10),
('李四', 10),
('王五', 10),
('赵六', 10),
('盖聂', 9000)

# 上面的语句一次会插入5条数据
</code></pre>
<p>我们需要做的就是生成此语句就可以了。</p>
<h6 id="具体做法">具体做法</h6>
<p>Mapper接口</p>
<pre><code class="language-java">int batchInsertUser(List&lt;User&gt; userList);
</code></pre>
<p>Mapper映射文件</p>
<pre><code class="language-xml">&lt;insert id=&quot;batchInsertUser&quot;&gt;
	insert into user (username, age) values
    &lt;forEach collection=&quot;list&quot; item=&quot;user&quot; separator=&quot;,&quot;&gt;
    	(#{user.username}, #{user.age})
    &lt;/forEach&gt;
&lt;/insert&gt;
</code></pre>
<h5 id="通过executorbatch的方式">通过Executor.BATCH的方式</h5>
<h6 id="实现原理-2">实现原理</h6>
<p>这种批量插入在底层的Mapper接口和Mapper映射文件中，都只是一个普通插入单条数据的写法。它通过在上层获取SqlSession时，指定执行类型是批量ExcecutorType.BATCH的方式，实现每次执行完单条插入以后并没有真正写入数据库，只有当调用sqlSession.flushStatement()时，才会将这一批数据一次性写入数据库，从而实现批量操作。</p>
<h6 id="使用步骤">使用步骤</h6>
<ol>
<li>
<p>获取SqlSession时指定执行类型为批量</p>
<pre><code class="language-java">// 获取一个批量执行的sqlSession对象
SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH);
</code></pre>
</li>
<li>
<p>Mapper接口和Mapper映射文件中只需按照单条插入去写方法和SQL语句即可</p>
<p>Mapper接口</p>
<pre><code class="language-java">int insertUser(User user);
</code></pre>
<p>XML映射文件</p>
<pre><code class="language-xml">&lt;insert id=&quot;insertUser&quot;&gt;
    insert into user (nick_name, status, createtime)
    values
    (#{nickName},#{status},#{createtime})
&lt;/insert&gt;
</code></pre>
</li>
<li>
<p>空置批量的大小，在够一批数据时，调用<code>sqlSession.flushStatement()</code>去整体往数据库写一次</p>
<pre><code class="language-java">int batchSize = 100;
int count = 0;
List&lt;BatchResult&gt; resultList = new ArrayList&lt;&gt;();
for(User user : userList) {
    // ExecutorType.Batch方式这里返回的不是影响的条数，具体获取方法参见下面代码
    mapper.insertUser(user);
    count++;
    if(count % batchSize == 0) {
        resultList.addAll(sqlSession.flushStatements());
    }
}
if(count % batchSize != 0) {
    resultList.addAll(sqlSession.flushStatements());
}
</code></pre>
</li>
<li>
<p>获取影响的条数</p>
<p>这种方式获取影响条数没有那么直接，需要去API返回的BatchResult对象中读取updateCounts方法才能拿到。</p>
<pre><code class="language-java">int rows = 0;
for(BatchResult batchResult : resultList) {
    int[] updateCounts = batchResult.getUpdateCounts();
    for(int updateCount : updateCounts) {
        rows += updateCount;
    }
}
System.out.println(&quot;批量插入成功，响应的行数：&quot; + rows);
</code></pre>
</li>
</ol>
<h4 id="缓存">缓存</h4>
<h5 id="一级缓存本地缓存">一级缓存（本地缓存）</h5>
<p>Mybatis的一级缓存是指Session缓存。一级缓存的作用域默认是一个SqlSession。Mybatis默认开启一级缓存。<br>
也就是在同一个SqlSession中，执行相同的查询SQL，第一次会去数据库进行查询，并写到缓存中；<br>
第二次以后是直接去缓存中取。<br>
当执行SQL查询中间发生了增删改的操作，MyBatis会把SqlSession的缓存清空。</p>
<blockquote>
<p>问题： 如果增删改的表和缓存的表是毫不相干的两个表，是否会清空缓存？</p>
<p>答 :    会清空</p>
</blockquote>
<h6 id="测试方法">测试方法</h6>
<ol>
<li>我们在一个 sqlSession 中，对 User 表根据id进行两次查询，查看他们发出sql语句的情况</li>
</ol>
<pre><code class="language-java">@Test
public void testSelectOrderAndUserByOrderId(){
    //根据 sqlSessionFactory 产生 session
    SqlSession sqlSession = sessionFactory.openSession();
    String statement = &quot;one.to.one.mapper.OrdersMapper.selectOrderAndUserByOrderID&quot;;
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
    //第一次查询，发出sql语句，并将查询的结果放入缓存中
    User u1 = userMapper.selectUserByUserId(1);
    System.out.println(u1);
     
    //第二次查询，由于是同一个sqlSession,会在缓存中查找查询结果
    //如果有，则直接从缓存中取出来，不和数据库进行交互
    User u2 = userMapper.selectUserByUserId(1);
    System.out.println(u2);
     
    sqlSession.close();
}
</code></pre>
<ol start="2">
<li>同样是对user表进行两次查询，只不过两次查询之间进行了一次update操作。</li>
</ol>
<pre><code class="language-java">@Test
public void testSelectOrderAndUserByOrderId(){
    //根据 sqlSessionFactory 产生 session
    SqlSession sqlSession = sessionFactory.openSession();
    String statement = &quot;one.to.one.mapper.OrdersMapper.selectOrderAndUserByOrderID&quot;;
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
    //第一次查询，发出sql语句，并将查询的结果放入缓存中
    User u1 = userMapper.selectUserByUserId(1);
    System.out.println(u1);
     
    //第二步进行了一次更新操作，sqlSession.commit()
    u1.setSex(&quot;女&quot;);
    userMapper.updateUserByUserId(u1);
    sqlSession.commit();
     
    //第二次查询，由于是同一个sqlSession.commit(),会清空缓存信息
    //则此次查询也会发出 sql 语句
    User u2 = userMapper.selectUserByUserId(1);
    System.out.println(u2);
     
    sqlSession.close();
}
</code></pre>
<h5 id="如何禁用一级缓存">如何禁用一级缓存</h5>
<ul>
<li>在映射文件中给对应的select标签上添加<code>flushCache=&quot;true&quot;</code>属性</li>
<li>在核心配置文件中将localCacheScope设置成STATEMENT（默认值是SESSION）</li>
</ul>
<h5 id="二级缓存全局缓存">二级缓存（全局缓存）</h5>
<h6 id="什么是二级缓存">什么是二级缓存？</h6>
<p>Mybatis中二级缓存相比一级（本地）缓存来说是一个作用域更大的缓存方案。 二级缓存的作用域可以跨多个SqlSession，只要是同一个namespace下的mapper映射文件都可以共享缓存。但是不能跨SqlSessionFactory。</p>
<p>Mybatis二级缓存需要手动开启。</p>
<h6 id="开启二级缓存的方法">开启二级缓存的方法</h6>
<p>1.在 SqlMapConfig.xml 文件开启二级缓存</p>
<pre><code class="language-xml">&lt;settings&gt; 
    &lt;!-- 开启全局二级缓存的支持 --&gt;  
    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; 
&lt;/settings&gt; 
</code></pre>
<p>2.配置相关的 Mapper 映射文件 (因为二级缓存就是针对特定的mapper namespace的)</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 
&lt;!DOCTYPE mapper     
PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;     
&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; 
&lt;mapper namespace=&quot;com.itheima.dao.IUserDao&quot;&gt;  
    &lt;!-- 开启二级缓存的支持 --&gt;  
    &lt;cache /&gt;
&lt;/mapper&gt;
</code></pre>
<blockquote>
<p><cache>标签表示当前这个 mapper 映射将使用二级缓存，能否命中二级缓存就看多次查询是否属于同一个namespace。</p>
</blockquote>
<ol start="3">
<li>设置某个特定的查询语句不用二级缓存</li>
</ol>
<pre><code class="language-xml">&lt;!-- 根据 id 查询 --&gt; 
&lt;select id=&quot;findById&quot; resultType=&quot;user&quot; parameterType=&quot;int&quot; useCache=&quot;false&quot;&gt;  
    select * from user where id = #{uid} 
&lt;/select&gt; 
</code></pre>
<blockquote>
<p>注意： 如果mapper文件中没有开启 <cache /> 仅在语句上添加useCache=&quot;true&quot;是无法开启二级缓存的。这个属性本意是用来关闭特定查询的二级缓存。</p>
</blockquote>
<h6 id="二级缓存注意事项">二级缓存注意事项</h6>
<blockquote>
<p>当我们在使用二级缓存时，所缓存的类一定要实现 java.io.Serializable 接口，这种就可以使用序列化 方式来保存对象。</p>
</blockquote>
<pre><code class="language-java">public class User implements Serializable { }
</code></pre>
<h4 id="mybatis逆向工程">Mybatis逆向工程</h4>
<h2 id="spring与mybatis整合">Spring与Mybatis整合</h2>
<ol>
<li>
<p>加入依赖</p>
<pre><code class="language-xml">&lt;!-- mybatis-spring整合依赖，这个是最主要的一个依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;version&gt;2.0.1&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- Spring和数据源相关依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid&lt;/artifactId&gt;
    &lt;version&gt;1.1.20&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>在Spring bean配置文件中配置Mybatis、Spring整合bean  SqlSessionFactoryBean</p>
<pre><code class="language-xml">&lt;!-- 配置整合bean --&gt;
&lt;bean id=&quot;sessionFactoryBean&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
    &lt;!-- 数据源是必要参数 --&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
    &lt;!-- Mybatis核心配置文件其实大多数情况下都可以省略，通过指定属性可以间接设置核心配置文件中的参数 --&gt;
    &lt;!--&lt;property name=&quot;configLocation&quot; value=&quot;mybatis_conf.xml&quot; /&gt;--&gt;

    &lt;!-- 省略mybatis核心配置文件后，可以通过类似下面这些特定属性，设置mybatis参数 --&gt;
    &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.lanou3g.mybatis.spring.bean&quot; /&gt;
    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot; /&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>在Spring bean配置文件中开启Mybatis Mapper扫描</p>
<ol>
<li>
<p>需要使用mybatis schema</p>
<p>配置方法，在bean配置文件的头部添加</p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mybatis=&quot;http://mybatis.org/schema/mybatis-spring&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
        http://mybatis.org/schema/mybatis-spring
        http://mybatis.org/schema/mybatis-spring.xsd&quot;&gt;
</code></pre>
</li>
<li>
<p>开启Mybatis Mapper扫描</p>
<p>开启Mybatis Mapper扫描的作用是：告诉Mybatis要创建哪个包下接口的实现类，并以bean的方式加入到SpringIOC容器中</p>
<pre><code class="language-xml">&lt;!-- 开启Mapper扫描，Mybatis会创建将此包下的接口的实现类，并以bean的方式加入到SpringIOC容器中 --&gt;
&lt;mybatis:scan base-package=&quot;com.lanou3g.mybatis.spring.mapper&quot; /&gt;
</code></pre>
</li>
</ol>
</li>
<li>
<p>创建实体类、mapper映射文件、Mapper接口（可以通过Mybatis逆向工程直接生成）</p>
<p>Mapper接口</p>
<pre><code class="language-java">@Repository	//此注解不是必须的，因为MessageMapper类的实现类是由Mybatis创建并放到ioc容器中的，不是由Spring来创建的。
public interface MessageMapper {
    int insert(Message record);
    List&lt;Message&gt; selectAll();
}
</code></pre>
<p>实体类、映射文件 略</p>
</li>
<li>
<p>将Mapper接口用Spring自动注入的方式注入到需要的地方使用</p>
<p>MessageService.java</p>
<pre><code class="language-java">@Service
public class MessageService {
    @Autowired
    MessageMapper messageMapper;
    public List&lt;Message&gt; queryAllMessage() {
        return messageMapper.selectAll();
    }
}
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Framework总结]]></title>
        <id>https://klein-moretti.github.io/post/spring-framework-zong-jie</id>
        <link href="https://klein-moretti.github.io/post/spring-framework-zong-jie">
        </link>
        <updated>2018-11-28T12:13:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="springioc">SpringIOC</h1>
<h2 id="ioc容器概念">IOC容器概念</h2>
<p>IOC其实就是一个对象的容器。全称Inversion Of Control 控制反转，核心的作用就是将原来由开发人员来控制的对象管理操作交由Spring来管理。</p>
<p>SpringIOC不仅帮我们管理了对象的创建，还包括给对象增加了生命周期行为、作用域(单例、非单例)、懒加载。 配合Spring的DI， 更能方便的解决对象属性值注入、对象之间的依赖注入问题。</p>
<h2 id="ioc容器初始化方式">IOC容器初始化方式</h2>
<h3 id="classpathxmlapplicationcontext">ClassPathXmlApplicationContext</h3>
<p>加载类路径下的xml配置文件的方式，去初始化IOC容器上下文</p>
<pre><code class="language-java">// 加载单个xml配置，初始化上下文
ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext1.xml&quot;);

// 加载多个xml配置，初始化上下文
ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(new String[]{&quot;applicationContext1.xml&quot;, &quot;applicationContext2.xml&quot;});

// 加载当前运行类所在的类路径下所有以application开头的配置文件
ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;appliction*.xml&quot;);

// 加载工程中所有类路径下所有以application开头的配置文件
ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath*:appliction*.xml&quot;);

// 加载工程中所有类路径下所有以application或spring开头的配置文件
ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(new String[]{&quot;classpath*:appliction*.xml&quot;, &quot;classpath*:spring*.xml&quot;});
</code></pre>
<blockquote>
<p>配置文件路径中可以包含通配符(*)和前缀(classpath*:，代表所有类路径，包括源码类路径和单元测试类路径)</p>
</blockquote>
<h3 id="annotationconfigapplicationcontext">AnnotationConfigApplicationContext</h3>
<p>加载通过Java注解方式配置的Bean上下文。</p>
<pre><code class="language-java">// 加载单个注解配置，初始化上下文
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(MyConfiguration.class);

// 加载多个注解配置，初始化上下文
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(new Class[]{MyConfiguration1.class, MyConfiguration2.class});
</code></pre>
<h2 id="bean初始化方式">Bean初始化方式</h2>
<h3 id="构造方法方式最常用">构造方法方式（最常用）</h3>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;com.test.StudentDao&quot; /&gt;
</code></pre>
<h3 id="静态工厂方法">静态工厂方法</h3>
<pre><code class="language-xml">&lt;!-- 
	class：指定的是静态工厂类，而不是将要创建的对象类型
	factory-method: 指定的是工厂中的静态方法 
--&gt;
&lt;bean id=&quot;xx&quot; class=&quot;com.test.StudentDaoFactory&quot; factory-method=&quot;createDao&quot; /&gt;
</code></pre>
<h3 id="实例工厂方法">实例工厂方法</h3>
<pre><code class="language-xml">&lt;!-- 
	class：指定的是实例工厂类 
--&gt;
&lt;bean id=&quot;xxFactory&quot; class=&quot;com.test.StudentDaoFactory&quot; /&gt;
&lt;!-- 
	factory-bean：指定的是实例工厂对象
	factory-method: 指定的是工厂中的实例方法 
--&gt;
&lt;bean id=&quot;xx&quot; factory-bean=&quot;xxFactory&quot; factory-method=&quot;createDao&quot; /&gt;
</code></pre>
<h2 id="bean的命名">Bean的命名</h2>
<p>在XML中配置中可以通过<bean>标签上的id、name属性值给一个bean命名，以便在其他地方引用。</p>
<p>id属性： bean的唯一名称，只允许出现一个值。且同一个IOC容器中不允许出现两个id值一样的bean。</p>
<p>name属性： 和id类似也是给bean命名。但是name属性的值可以有多个，多个值之间使用英文逗号(,)或者英文分号(;)或者空格符隔开</p>
<h2 id="bean的作用域">Bean的作用域</h2>
<ul>
<li>
<p>prototype</p>
<p>在SpringIOC中prototype scope的意思指的是非单例，就是每次使用该bean的时候都会重新创建一个对象。</p>
<figure data-type="image" tabindex="1"><img src="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/images/prototype.png" alt="原型作用域示意图"></figure>
</li>
<li>
<p>singleton(默认)</p>
<p>singleton作用域是IOC中默认的作用域，代表单例。每次使用bean的时候，不会重新创建对象，在整个IOC容器中该类型的对象只有一个。</p>
<figure data-type="image" tabindex="2"><img src="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/images/singleton.png" alt="单例作用域示意图"></figure>
</li>
</ul>
<h2 id="bean的生命周期">Bean的生命周期</h2>
<ul>
<li>
<p>Singleton Bean的生命周期</p>
<ul>
<li>初始化时机： 在IOC容器初始化时，就会把配置的所有单例bean实例化。</li>
<li>销毁时机：在IOC容器销毁时，所有bean的销毁方法会被调用。</li>
</ul>
</li>
<li>
<p>Prototype Bean的生命周期</p>
<ul>
<li>初始化时机： 在实际使用该bean的时候，比如：getBean、获取依赖此bean的其他bean需要使用</li>
<li>销毁时机： 在IOC容器销毁时。（但是通过destroy-method指定的声明周期方法不会被调用，也就是说Spring不提供prototypebean完整的生命周期管理）</li>
</ul>
</li>
<li>
<p>如何指定生命周期的回调方法</p>
<ul>
<li>xml中的init-method、destroy-method</li>
<li>注解方式@PostConstrutor、@PreDestroy</li>
</ul>
</li>
<li>
<p>指定默认的声明周期回调方法</p>
<ul>
<li>在xml中，通过在beans标签上添加default-init-method、default-destory-method来指定</li>
<li>在注解配置中，没有对应的方法可以设置所有bean默认的生命周期回调</li>
</ul>
</li>
</ul>
<h2 id="bean懒加载">Bean懒加载</h2>
<p>lazy-init属性</p>
<p>默认是false</p>
<blockquote>
<p>懒加载配置主要是针对单例的bean，因为它默认是在容器初始化时就被实例化了。</p>
</blockquote>
<h2 id="如何优雅的停止非web-spring应用">如何优雅的停止非Web Spring应用</h2>
<p>添加一个shutdown hook。所有派生自ConfigurableApplicationContext接口的实现类都支持此方法</p>
<pre><code class="language-java">ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;xxx.xml&quot;);

ctx.registerShutdownHook(); //注册停止回调
</code></pre>
<h1 id="spring-di">Spring DI</h1>
<h2 id="概述">概述</h2>
<p>DI的全称是Dependency Injection（依赖注入）。IOC是将我们工程中的所有对象交由Spring来管理，DI是此基础，将对象中的属性、依赖的其他对象也管理起来，自动注入到由Spring帮我们管理的对象中。</p>
<blockquote>
<p>将要注入的对象和目标对象都必须是由SpringIOC管理的bean.</p>
</blockquote>
<h2 id="di的细节实现">DI的细节实现</h2>
<h3 id="构造参数注入">构造参数注入</h3>
<p>将一个bean创建过程中构造方法需要的参数，通过Spring DI的方式，自动注入到构造方法中。</p>
<h3 id="setter注入">Setter注入</h3>
<p>先通过一个无参的构造方法创建对象，然后通过属性的setter方法，将属性值注入到对象上。</p>
<h3 id="支持注入的类型">支持注入的类型</h3>
<ul>
<li>
<p>普通字面量</p>
<ul>
<li>String</li>
<li>Integer(int)</li>
<li>Long(long)</li>
<li>Byte(byte)</li>
<li>...</li>
</ul>
</li>
<li>
<p>集和类型</p>
<ul>
<li>
<p>List</p>
<pre><code class="language-xml">&lt;bean id=&quot;xxx&quot; class=&quot;xx.xxx.xxx.AA&quot;&gt;&lt;/bean&gt;
&lt;bean&gt;
    &lt;property name=&quot;hobbies&quot;&gt;
    	&lt;list&gt;
        	&lt;value&gt;简单类型值&lt;/value&gt;
            &lt;bean&gt;内部bean&lt;/bean&gt;
            &lt;ref bean=&quot;xxx&quot; /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>Map</p>
<pre><code class="language-xml">&lt;bean id=&quot;xxx&quot; class=&quot;xx.xxx.xxx.AA&quot;&gt;&lt;/bean&gt;
&lt;bean&gt;
    &lt;property name=&quot;gameTitle&quot;&gt;
    	&lt;map&gt;
        	&lt;entry key=&quot;王者荣耀&quot; value=&quot;荣耀王者&quot; /&gt;
            &lt;entry key=&quot;王者荣耀&quot; value-ref=&quot;xxx&quot; /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>Set</p>
<pre><code class="language-xml">&lt;bean id=&quot;xxx&quot; class=&quot;xx.xxx.xxx.AA&quot;&gt;&lt;/bean&gt;
&lt;bean&gt;
    &lt;property name=&quot;hobbies&quot;&gt;
    	&lt;!-- set用法和List类似， 里面可以注入普通字面量值、也可以是一个bean引用，或者内部bean、或者是一个set、list、Properties  --&gt;
        &lt;set&gt;
        	&lt;value&gt;简单类型值&lt;/value&gt;
            &lt;bean&gt;内部bean&lt;/bean&gt;
            &lt;ref bean=&quot;xxx&quot; /&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>java.util.Properties</p>
<pre><code class="language-xml">&lt;!-- props标签是用来注入java.util.Properties类型的属性，用法和map类似，但是属性值是在标签中间写 --&gt;
&lt;property name=&quot;gameNick&quot;&gt;
    &lt;props&gt;
        &lt;prop key=&quot;王者荣耀&quot;&gt;最擅长1V5&lt;/prop&gt;
        &lt;prop key=&quot;吃鸡&quot;&gt;一枪爆头&lt;/prop&gt;
    &lt;/props&gt;
&lt;/property&gt;
</code></pre>
</li>
<li>
<p>注入空置、空字符串</p>
<pre><code class="language-xml">&lt;property name=&quot;gameNick&quot;&gt;
    &lt;null /&gt;
&lt;/property&gt;


&lt;property name=&quot;gameNick&quot; value=&quot;&quot; /&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="自动装配">自动装配</h3>
<h5 id="自动装配支持的策略">自动装配支持的策略</h5>
<ul>
<li>
<p>byType</p>
<p>按照类型去IOC容器中找需要的bean，如果找到一个，则自动装配；如果没找到，不注入此属性；如果找到了多个匹配类型的bean，就会报错。</p>
</li>
<li>
<p>byName</p>
<p>按照名称去IOC容器中找需要的bean，如果找到就自动注入；如果没找到，不注入此属性。</p>
</li>
<li>
<p>constructor</p>
<p>工作原理和byType类似，也是按照类型去IOC容器中找对应的bean。不同的是注入的地方不是setter，而是构造方法的参数。</p>
</li>
<li>
<p>no  （默认值）</p>
<p>如果没有打开自动注入，默认Spring不会自动装配需要的属性。</p>
</li>
</ul>
<h2 id="xml方式的di">XML方式的DI</h2>
<h3 id="构造参数注入-2">构造参数注入</h3>
<ul>
<li>
<p>常规写法</p>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;&quot; /&gt;
&lt;bean class=&quot;com.test.XXX&quot;&gt;
	&lt;constructor-arg name=&quot;age&quot; value=&quot;45&quot; /&gt;
    &lt;constructor-arg name=&quot;x&quot; ref=&quot;xx&quot; /&gt;  &lt;!-- 注入引用的bean --&gt;
    &lt;constructor-arg name=&quot;&quot;&gt;	&lt;!-- 注入内部bean --&gt;
    	&lt;bean&gt;&lt;/bean&gt;
    &lt;/constructor-arg&gt;
    &lt;constructor-arg name=&quot;&quot;&gt;	&lt;!-- 注入list类型构造参数 --&gt;
    	&lt;list&gt;
        	
        &lt;/list&gt;
    &lt;/constructor-arg&gt;
    ....
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>c命名空间简写</p>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;&quot; /&gt;
&lt;bean class=&quot;com.test.XXX&quot; c:age=&quot;45&quot; c:x-ref=&quot;xx&quot; /&gt;
</code></pre>
</li>
</ul>
<h3 id="setter方式注入">setter方式注入</h3>
<p>setter注入能够注入的类型以及写法基本和构造参数注入时的写法一致，只不过将<construtor-arg>标签换成了<property></p>
<ul>
<li>
<p>常规用法</p>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;&quot; /&gt;
&lt;bean class=&quot;com.test.XXX&quot;&gt;
	&lt;property name=&quot;age&quot; value=&quot;45&quot; /&gt;
    &lt;property name=&quot;x&quot; ref=&quot;xx&quot; /&gt;  &lt;!-- 注入引用的bean --&gt;
    &lt;property name=&quot;&quot;&gt;	&lt;!-- 注入内部bean --&gt;
    	&lt;bean&gt;&lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name=&quot;&quot;&gt;	&lt;!-- 注入list类型构造参数 --&gt;
    	&lt;list&gt;
        	
        &lt;/list&gt;
    &lt;/property&gt;
    ....
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>p命名空间简写</p>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;&quot; /&gt;
&lt;bean class=&quot;com.test.XXX&quot; p:age=&quot;45&quot; p:x-ref=&quot;xx&quot; /&gt;
</code></pre>
</li>
</ul>
<h3 id="开启自动装配">开启自动装配</h3>
<pre><code class="language-xml">&lt;!-- 
通过给当前的bean添加autowire属性开启自动注入
可选的值：参见自动装配章节
 --&gt;
&lt;bean id=&quot;xx&quot; class=&quot;&quot; autowire=&quot;&quot; /&gt;
</code></pre>
<h3 id="提高自动装配时的权重">提高自动装配时的权重</h3>
<pre><code class="language-xml">&lt;!-- 当其他的bean中需要注入一个Test类型的属性，而满足条件的bean有多个时，会优先注入primary=&quot;true&quot;的bean --&gt;
&lt;bean id=&quot;xx&quot; class=&quot;com.Test&quot; primary=&quot;true&quot; /&gt;
</code></pre>
<h3 id="按类型自动装配时不参与候选">按类型自动装配时，不参与候选</h3>
<pre><code class="language-xml">&lt;!-- 当其他的bean中需要注入一个Test类型的属性，而满足条件的bean有多个时，autowire-candidate=&quot;false&quot;的bean会自动退出候选序列 --&gt;
&lt;bean id=&quot;xx&quot; class=&quot;com.Test&quot; autowire-candidate=&quot;false&quot; /&gt;
</code></pre>
<h2 id="注解方式的di">注解方式的DI</h2>
<ul>
<li>
<p>构造参数注入</p>
<p>在构造方法上添加 <code>@Autowired</code>注解，构造方法的参数就会自动注入进来</p>
</li>
<li>
<p>setter方法注入</p>
<p>方法有两种：</p>
<ol>
<li>在属性的setter方法上添加<code>@Autowired</code>注解</li>
<li>在属性上添加<code>@Autowired</code>注解</li>
</ol>
</li>
</ul>
<h3 id="提高自动装配时的权重-2">提高自动装配时的权重</h3>
<pre><code class="language-java">@Primary
@Component
public class Test {


}

public class Main {
    
    @Primary
    @Bean
    public void test() {
        return new Test();
    }
    
}
</code></pre>
<h1 id="springaop">SpringAOP</h1>
<h2 id="概述-2">概述</h2>
<p>AOP的全称是Aspect Oriented  Programming(面向切面编程)</p>
<p>OOP语言提供了类与类之间纵向的关系（继承、接口），而AOP补充了横向的关系（比如在不改变目标类中源代码的情况下给com.john.demo.dao包下所有类中以insert和update开头的方法添加事务管理）</p>
<h3 id="springaop和aspectj的区别">SpringAOP和AspectJ的区别</h3>
<p>AspectJ是一个专门主打面向切面编程的框架。 它是使用一种特殊的语言(扩展自Java语言)来编写切面代码，后缀是.aj格式，并且需要使用专门的编译器将其编译成jvm可以运行的class文件。</p>
<p>SpringAOP底层也是使用了AspectJ的方案，但是在上层做了很多封装层面的工作，可以让开发人员直接使用Java代码来编写切面。并且由于使用的是标准的Java语言，所以并不需要在额外安装一个专门的编译器。但是由于开发人员直接接触的是Spring AOP，那么凡是Spring中没有实现的那些AOP功能，我们就用不了了，这种情况下只能跟产品经理撕逼或者去学习原生的AspectJ。</p>
<h2 id="aop的术语">AOP的术语</h2>
<ul>
<li>
<p>切面（Aspect）</p>
<p>简单来说，切面就是我们要往目标代码中插入进去的代码。</p>
</li>
<li>
<p>连接点（Join Pointer）</p>
<p>理论上所有可能会被切入的地方都可以称之为连接点</p>
</li>
<li>
<p>切入点(Pointcut)</p>
<p>选择某个连接点切入，将切面代码织入进去。这个连接点就叫做切入点。</p>
</li>
<li>
<p>织入(Weaving)</p>
<p>把切面代码糅合到目标代码中的过程就是织入。</p>
</li>
<li>
<p>通知(Advice)</p>
<p>通知决定了切面代码织入到目标代码中后，运行的时机(比如是在目标方法执行前，还是执行后)。</p>
</li>
</ul>
<h2 id="在spring中使用aop">在Spring中使用AOP</h2>
<h3 id="基于xml方式使用">基于XML方式使用</h3>
<ol>
<li>
<p>把aop的schema引入</p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
</code></pre>
</li>
<li>
<p>创建一个切面类，并且以bean的方式配置到IOC容器中</p>
<pre><code class="language-java">package com.lanou3g.spring;
public class MyAspect {

    public void wakeup() {
        System.out.println(&quot;[前置通知]我刚学习SpringAOP睡着了，刚才谁打了我一下？&quot;);
    }


    public void goToBed() {
        System.out.println(&quot;[后置通知]SpringAOP太难了，一不小心又睡着了&quot;);
    }


    public void afterRetuing(Object message) {
        System.out.println(&quot;[后置返回通知]方法执行已经return了，方法返回值是：&quot; + message);
    }

    public void afterThrowing(Throwable ex) {
        System.out.println(&quot;[后置异常通知]方法执行出现异常，异常原因：&quot; + ex.getMessage());
    }

    /**
     * 环绕通知
     * 可以接受一个ProceedingJoinPoint参数
     *      通过此参数可以获取到被切入方法的所有信息
     *      还可以通过此参数来决定是否调用目标方法
     */
    public void aroundAdvice(ProceedingJoinPoint joinPoint) {

        // 连接点参数可以获取到被切入方法的所有信息
        // 这里演示了如何获取被切入方法的名称
        String targetMethodName = joinPoint.getSignature().getName();
        System.out.println(&quot;[环绕通知]被切入的方法名：&quot; + targetMethodName);

        //
        System.out.println(&quot;[环绕通知]即将开始新的一天， 早起的鸟儿有虫吃！&quot;);
        try {
            joinPoint.proceed();
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        System.out.println(&quot;[环绕通知]这真是充实的一天， 早睡早起，方能养生！&quot;);
    }
}
</code></pre>
<pre><code class="language-xml">&lt;bean id=&quot;myAspect&quot; class=&quot;com.lanou3g.spring.MyAspect&quot; /&gt;
</code></pre>
</li>
<li>
<p>使用<a href="aop:config">aop:config</a>标签配置aop（将切面、切入点、通知结合到一起）</p>
<ol>
<li>定义切入点表达式</li>
<li><a href="aop:aspect">aop:aspect</a>
<ol>
<li>引用外部定义的切面bean</li>
<li>配置通知，引用切入点表达式</li>
</ol>
</li>
</ol>
<pre><code class="language-xml">&lt;aop:config&gt;
    &lt;!-- 切入点表示匹配com.lanou3g.spring包下的所有类中所有以oneDay开头的方法，方法的参数、返回值不限 --&gt;
	&lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(* com.lanou3g.spring..*.oneDay*(..))&quot; /&gt;
    &lt;aop:aspect ref=&quot;myAspect&quot;&gt;
    	&lt;!-- 无论是否出现异常，只要被切入的方法开始运行，都会触发此通知 --&gt;
            &lt;aop:before method=&quot;wakeup&quot; pointcut-ref=&quot;beforeOneDay&quot; /&gt;
            &lt;!-- 无论是否出现异常，只要被切入的方法运行结束，都会触发此通知 --&gt;
            &lt;aop:after method=&quot;goToBed&quot; pointcut-ref=&quot;beforeOneDay&quot; /&gt;
            &lt;!--
            可以最大限度的对被切入方法附加功能，在方法执行前、后都可以通知（无论是否出现异常）
            ，还可以获取到被切入方法的所有信息，包括是否调用被切入的方法
            --&gt;
            &lt;aop:around method=&quot;aroundAdvice&quot; pointcut-ref=&quot;beforeOneDay&quot; /&gt;
            &lt;!-- 被切入的方法正常返回值以后，会触发此通知 --&gt;
            &lt;aop:after-returning method=&quot;afterRetuing&quot; pointcut-ref=&quot;beforeOneDay&quot; returning=&quot;message&quot; /&gt;
            &lt;!-- 被切入的方法抛出异常以后，会触发此通知，并且不会触发after-returning --&gt;
            &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;beforeOneDay&quot; throwing=&quot;ex&quot; /&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>
</li>
</ol>
<h3 id="基于注解方式使用">基于注解方式使用</h3>
<ol>
<li>
<p>开启AOP注解支持</p>
<p>方式一：注解的方式</p>
<pre><code class="language-xml">@Configuration
@EnableAspectJAutoProxy
public class AppConfig {

}
</code></pre>
<p>方式二：xml中开启</p>
<pre><code class="language-xml">&lt;aop:aspectj-autoproxy/&gt;
</code></pre>
<ol start="2">
<li>定义切面类</li>
</ol>
<pre><code class="language-java">/**
 * 该切面用来插入起床的逻辑
 */
@Aspect
@Component  //@Aspect注解没有将bean交给ioc容器管理的功能
public class MyAspect {

    @Before(&quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;)
    public void wakeup() {
        System.out.println(&quot;[前置通知]我刚学习SpringAOP睡着了，刚才谁打了我一下？&quot;);
    }

    @After(&quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;)
    public void goToBed() {
        System.out.println(&quot;[后置通知]SpringAOP太难了，一不小心又睡着了&quot;);
    }

    @AfterReturning(value = &quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;, returning = &quot;message&quot;)
    public void afterRetuing(Object message) {
        System.out.println(&quot;[后置返回通知]方法执行已经return了，方法返回值是：&quot; + message);
    }

    @AfterThrowing(value = &quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;, throwing = &quot;ex&quot;)
    public void afterThrowing(Throwable ex) {
        System.out.println(&quot;[后置异常通知]方法执行出现异常，异常原因：&quot; + ex.getMessage());
    }

    /**
     * 环绕通知
     * 可以接受一个ProceedingJoinPoint参数
     *      通过此参数可以获取到被切入方法的所有信息
     *      还可以通过此参数来决定是否调用目标方法
     */
//    @Around(&quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;)
    public Object aroundAdvice(ProceedingJoinPoint joinPoint) {

        // 连接点参数可以获取到被切入方法的所有信息
        // 这里演示了如何获取被切入方法的名称
        String targetMethodName = joinPoint.getSignature().getName();
        System.out.println(&quot;[环绕通知]被切入的方法名：&quot; + targetMethodName);

        //
        System.out.println(&quot;[环绕通知]即将开始新的一天， 早起的鸟儿有虫吃！&quot;);
        Object ret = null;
        try {
            ret = joinPoint.proceed();
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        System.out.println(&quot;[环绕通知]这真是充实的一天， 早睡早起，方能养生！&quot;);
        return ret;
    }
}
</code></pre>
<blockquote>
<p>注意：@Aspect注解没有将bean交给ioc容器管理的功能，我们需要额外添加一个@Component注解</p>
</blockquote>
<ol start="3">
<li>定义切入点</li>
</ol>
<p>官方建议我们将所有的切入点统一定义到一个地方管理，在配置通知时通过引入的方式来使用。方便后期维护（一处修改，处处生效）</p>
<pre><code class="language-java">@Component
public class MyPointcut {
    // 通过@Pointcut注解定义一个切入点
    @Pointcut(&quot;execution(* oneDay(..))&quot;)
    public void allOneDayMehtod() {}
}
</code></pre>
<ol start="4">
<li>在切面类中添加要切入的代码</li>
</ol>
<blockquote>
<p>参见定义切面部分</p>
</blockquote>
<ol start="5">
<li>在切入的代码方法上添加通知的注解</li>
</ol>
<blockquote>
<p>参见定义切面部分</p>
</blockquote>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA常见异常状态码]]></title>
        <id>https://klein-moretti.github.io/post/java-chang-jian-yi-chang-zhuang-tai-ma</id>
        <link href="https://klein-moretti.github.io/post/java-chang-jian-yi-chang-zhuang-tai-ma">
        </link>
        <updated>2018-11-26T11:34:21.000Z</updated>
        <content type="html"><![CDATA[<p>4xx（请求错误）<br>
这些状态代码表示请求可能出错，妨碍了服务器的处理。</p>
<p>代码 说明<br>
==400 ==（错误请求） 服务器不理解请求的语法。<br>
401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>
403 （禁止） 服务器拒绝请求。<br>
404 （未找到） 服务器找不到请求的网页。<br>
405 （方法禁用） 禁用请求中指定的方法。<br>
406 （不接受） 无法使用请求的内容特性响应请求的网页。<br>
407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。<br>
408 （请求超时） 服务器等候请求时发生超时。<br>
409 （冲突） 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。<br>
410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。<br>
411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。<br>
412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。<br>
413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。<br>
414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。<br>
415 （不支持的媒体类型） 请求的格式不受请求页面的支持。<br>
416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。<br>
417 （未满足期望值） 服务器未满足&quot;期望&quot;请求标头字段的要求。</p>
<p>5xx（服务器错误）<br>
这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p>
<p>代码 说明<br>
500 （服务器内部错误） 服务器遇到错误，无法完成请求。<br>
501 （尚未实施） 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。<br>
502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。<br>
503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。<br>
504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>
505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux常用命令]]></title>
        <id>https://klein-moretti.github.io/post/linux-chang-yong-ming-ling</id>
        <link href="https://klein-moretti.github.io/post/linux-chang-yong-ming-ling">
        </link>
        <updated>2018-10-12T08:28:43.000Z</updated>
        <content type="html"><![CDATA[<p>目录结构：<br>
https://www.runoob.com/linux/linux-system-contents.html</p>
<ol>
<li>在虚拟机中安装Centos操作系统<br>
使用VirtualBox虚拟机工具安装centos6操作系统</li>
</ol>
<p>**1.1 Linux **SSH操作终端<br>
使用SecureCRT工具通过ssh服务远程连接到linux，通过命令行操作</p>
<p>1.2. Linux常用命令<br>
目录相关命令：<br>
ls: 查看当前目录文件</p>
<p>ll:查看所有以及</p>
<p>cd: 切换工作目录 如: cd ~ （进入当前用户home目录）</p>
<p>pwd: 显示当前工作目录</p>
<p>mkdir: 新建目录</p>
<p>mkdir -p /././. :创建多级目录</p>
<p>cd … :跳出到根目录（到上一级目录 ）</p>
<p>ls-命令参数 :</p>
<p>-a 显示所有文件及目录 (ls内定将文件名或目录名称开头为&quot;.&quot;的视为隐藏档，不会列出)<br>
-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出<br>
-r 将文件以相反次序显示(原定依英文字母次序)<br>
-t 将文件依建立时间之先后次序列出<br>
-A 同 -a ，但不列出 “.” (目前目录) 及 “…” (父目录)<br>
-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/”<br>
-R 若目录下有文件，则以下之文件亦皆依序列出<br>
文件操作相关：<br>
cat: 查看文件内容</p>
<p>tail -fn 100 /etc/passwd （查看文件最后100行， 自动刷新，非常适合看日志）</p>
<p>rm: 删除</p>
<p>mv: 移动文件 (如果还移动到当前目录，就是重命名)</p>
<p>touch: 创建一个空文件</p>
<p>sz [文件名] ：下载Linux上的文件到本地系统</p>
<p>使用指令&quot;cp&quot;将当前目录&quot;test/&quot;下的所有文件复制到新目录&quot;newtest&quot;下，输入如下命令：</p>
<p>$ cp –r test/ newtest<br>
1<br>
**我们知道cp是复制，mv就是剪切，在windows下的叫法，在linux下二者还有一个区别，就是生成的文件的权限不一定相同。</p>
<p>**mv只是移动了文件，文件的一切都没有改变，而cp是在目标文件夹中创建了新的文件。</p>
<p>VIM 文本编辑相关：<br>
vim: linux上的一个强大的文本编辑器</p>
<p>保存并退出： :wq(命令模式下)、 ZZ（命令模式下）</p>
<p>不保存退出：:q! (命令模式下)</p>
<p>从命令模式切换到编辑模式： a、i、o</p>
<p>跳到文件头： gg</p>
<p>跳到文件尾：GG</p>
<p>进程相关命令：<br>
查看当前系统中运行了哪些进程：ps aux | grep vsftp (查看当前有没有运行ftp进程)</p>
<p>杀进程： kill -9 [进程号]</p>
<p>Centos安装包管理器Yum 命令：<br>
查看已安装的程序：sudo yum list installed | grep vsftp (查看是否安装了vsftp软件)</p>
<p>卸载已安装程序： sudo yum remove vsftpd.i686</p>
<p>安装程序： sudo yum install vsftpd</p>
<p>Centos防火墙命令相关:<br>
查看防火墙状态：service iptables status</p>
<p>关闭防火墙：service iptables stop</p>
<p>开启防火墙：service iptables start</p>
<p>服务开机自启动：<br>
chkconfig vsftpd on (设置vsftpd服务开机自启动)</p>
<p>关机服务开机自启：<br>
chkconfig iptables off (设置防火墙服务不开机自启)</p>
<p>关机：sudo halt –p</p>
<p>重启: sudo reboot</p>
<p>用户相关：<br>
useradd user1——创建用户user1</p>
<p>使用 passwd 命令为新建用户设置密码：password user1</p>
<p>命令 usermod 修改用户账户：usermod –l u1 user1 改名字</p>
<p>usermod –g users user1 ：加入用户组</p>
<p>su user :查询进入用户</p>
<p>sudo password user：重置这个用户的密码</p>
<p>删除用户：userdel user2</p>
<p>删除用户 user3，同时删除他的工作目录：userdel –r user3</p>
<p>d命令查看一个用户的UID和GID, 例：查看user4的id：：id user4<br>
finger命令 ——可以查看用户的主目录、启动shell、用户名、地址、电话等信息</p>
<p>命令 groupadd创建用户组：：groupadd –g 888 users ：：创建一个组users，其GID为888</p>
<p>两种方式，我们以kill用户user为例:</p>
<p>pkill方式<br>
pkill -u user</p>
<p>killall方式<br>
killall -u user</p>
<p>其他：<br>
sudo make &amp;&amp; make install：同时执行多个简单的命令</p>
<p>./configure\：后面的\是转义，代表不换行太长了继续编辑</p>
<p>ps aux | grep nginx ：查看是否启动（也是查看有无进程）</p>
<p>wget url ：直接根据url链接下载</p>
<p>rz -be:上传本地的文件到Linux</p>
<p>tar -zxf 。。。。：解压tar包</p>
<p>语法：unzip ［选项］ 压缩文件名.zip</p>
<p>sudo ./nginx -s reload :热加载（修改了配置文件后不重启，热加载让其生效！）</p>
<p>查看虚拟机IP：：ip address</p>
<p>ll -a | grep sudoers ：查看文件权限</p>
<p>chmod 664 sudoers：添加文件权限</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringMVC总结]]></title>
        <id>https://klein-moretti.github.io/post/springmvc-zong-jie</id>
        <link href="https://klein-moretti.github.io/post/springmvc-zong-jie">
        </link>
        <updated>2018-07-31T12:02:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="springmvc">SpringMVC</h1>
<h2 id="mvc设计模式">MVC设计模式</h2>
<p>其实在之前JavaWeb阶段我们已经接触到了MVC模式。</p>
<p>MVC里面的M指的的Model（通常包含bean、dao(mapper)、service）；V指的是View，视图层，视图层主要的技术（JSP、HTML、FreeMaker、Themeleaf）；C指的是Controller，控制层。控制层不负责具体数据、逻辑的处理和运算，它只负责将Model层的结果返回给对应的视图层去展示。</p>
<p>在JavaWeb阶段， Controller层指的就是Servlet； View层指的就是JSP或者HTML;  Model层指的就是bean、dao、service。</p>
<p>在J2EE阶段，Controller层指的就是SpringMVC、Structs1\2；  View层不变还是主流的页面展示技术; Model层包括bean、mybatis、service。</p>
<h2 id="springmvc的优势">SpringMVC的优势</h2>
<ul>
<li>SpringMVC是一款很轻量级的框架，要使用它的组件我们往往只需要定义一些最简单的Java类，然后添加某些注解就可以了</li>
<li>SpringMVC的参数注入只直接注入到方法中，可以很好的做到不同请求间数据的隔离，而Struts2是注入到类实例变量上，不同的请求可能会覆盖参数。</li>
<li>SpringMVC可以很轻易的和Spring整合，而Struts需要做比较复杂的配置。</li>
</ul>
<h2 id="springmvc简单使用">SpringMVC简单使用</h2>
<ol>
<li>
<p>添加依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>在web.xml中配置DispatcherServlet</p>
<pre><code class="language-xml">&lt;servlet&gt;
    &lt;servlet-name&gt;aa&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!-- 指定SpringMVC 配置文件位置，DispatcherServlet初始化时会初始化Spring上下文（WebApplicationContext） --&gt;
    &lt;!-- 默认配置文件寻找位置：/WEB-INF/{servlet-name}-servlet.xml，如果名字符合默认寻找规则，可以不指定配置文件路径 --&gt;
    &lt;!--&lt;init-param&gt;
      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
      &lt;param-value&gt;/WEB-INF/aa-servlet.xml&lt;/param-value&gt;
    &lt;/init-param&gt;--&gt;
    &lt;!-- 配置容器启动时初始化DispatcherServlet --&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;aa&lt;/servlet-name&gt;
    &lt;!-- 映射路径配置成/，代表当前Servlet是一个默认Servlet，就是当其他Servlet都无法处理请求时，由默认Servlet出马 --&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;!--    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;--&gt;
  &lt;/servlet-mapping&gt;
</code></pre>
</li>
<li>
<p>配置SpringMVC  dispatcher-servlet.xml</p>
<p>SpringMVC大部分组件都有默认配置，我们一般简单应用只需要指定视图解析器就行了</p>
<p>dispatcher-servlet.xml</p>
<pre><code class="language-xml">&lt;!-- 配置视图解析器，用于将Handler方法中返回的视图名解析成真正可展示的页面 --&gt;
&lt;mvc:view-resolvers&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/&quot; /&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;
&lt;/mvc:view-resolvers&gt;
</code></pre>
</li>
<li>
<p>定义Controller</p>
<p>新建一个普通类，然后添加<code>@Controller</code>注解，就可以了</p>
</li>
<li>
<p>定义请求处理方法(Handler)</p>
<p>在Controller类中定义一个普通的方法，添加<code>@RequestMapping</code>注解就可以了</p>
</li>
</ol>
<h2 id="springmvc主要组件">SpringMVC主要组件</h2>
<h3 id="rootapplicationcontext和servletapplicationcontext">RootApplicationContext和ServletApplicationContext</h3>
<figure data-type="image" tabindex="1"><img src="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/images/mvc-context-hierarchy.png" alt="父子上下文概念"></figure>
<h4 id="两个applicationcontext的联系和区别">两个ApplicationContext的联系和区别</h4>
<h3 id="视图解析器">视图解析器</h3>
<p>视图解析器的作用是将请求处理方法中的返回值解析成一个真正可以渲染的页面。</p>
<h4 id="常用的视图解析器">常用的视图解析器</h4>
<ul>
<li>
<p>InternalResourceViewResolver</p>
<p>内部资源解析器： 用于将返回值对应到项目路径下的某个可显示的页面。比如方法返回值是index字符串，那么<code>InternalResourceViewResolver</code>解析器会在index前加上指定的前缀，在index后加上指定的后缀来拼接成指向某个视图的路径。</p>
<pre><code class="language-xml">&lt;!-- 配置视图解析器，用于将Handler方法中返回的视图名解析成真正可展示的页面 --&gt;
&lt;mvc:view-resolvers&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/&quot; /&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;
&lt;/mvc:view-resolvers&gt;
</code></pre>
</li>
</ul>
<h3 id="参数传递">参数传递</h3>
<h4 id="页面参数传递到controller">页面参数传递到Controller</h4>
<h5 id="requestparam">@RequestParam</h5>
<p>获取请求参数，包括通过GET请求中的查询参数、POST请求中的参数等</p>
<pre><code class="language-java">@RequestMapping(&quot;/hello&quot;)
public String toHelloPage(@RequestParam String message, Model model) {
	model.addAttribute(&quot;msg&quot;, message);
	return &quot;hello_springmvc&quot;;
}


// 当方法参数名和请求参数不一样时，可以使用注解的参数对应起来
@RequestMapping(&quot;/hello&quot;)
public String toHelloPage(@RequestParam(&quot;message&quot;) String msg, Model model) {
	model.addAttribute(&quot;msg&quot;, message);
	return &quot;hello_springmvc&quot;;
}
</code></pre>
<blockquote>
<p>访问: http://localhost:8080/hello?message=zhangsan 时，message参数会自动注入到方法的message参数中。</p>
</blockquote>
<h5 id="requestheader">@RequestHeader</h5>
<p>获取请求头中的参数，如浏览器默认自带的userAgent就是请求头参数</p>
<pre><code class="language-java">@RequestMapping(&quot;/hello&quot;)
public String toHelloPage(@RequestHeader String userAgent, Model model) {
	model.addAttribute(&quot;msg&quot;, userAgent);
	return &quot;hello_springmvc&quot;;
}


// 当方法参数名和请求头参数不一样时，可以使用注解的参数对应起来
@RequestMapping(&quot;/hello&quot;)
public String toHelloPage(@RequestHeader(&quot;userAgent&quot;) String ua, Model model) {
	model.addAttribute(&quot;msg&quot;, ua);
	return &quot;hello_springmvc&quot;;
}
</code></pre>
<blockquote>
<p>会自动将请求头中的userAgent参数注入到方法中</p>
</blockquote>
<h5 id="pathvariable">@PathVariable</h5>
<p>获取请求地址中的参数，注入到方法参数中</p>
<pre><code class="language-java">@RequestMapping(&quot;/hello/{sname}&quot;)
public String toHelloPage(@PathVariable String sname, Model model) {
	model.addAttribute(&quot;msg&quot;, sname);
	return &quot;hello_springmvc&quot;;
}


// 当方法参数名和请求地址中参数不一样时，可以使用注解的参数对应起来
@RequestMapping(&quot;/hello/{sname}&quot;)
public String toHelloPage(@PathVariable(&quot;sname&quot;) String sn, Model model) {
	model.addAttribute(&quot;msg&quot;, sn);
	return &quot;hello_springmvc&quot;;
}
</code></pre>
<blockquote>
<p>访问：http://localhost:8080/hello/zhangsan  会自动将zhangsan注入到方法的参数中</p>
</blockquote>
<h5 id="requestattribute">@RequestAttribute</h5>
<p>jsp中</p>
<pre><code class="language-jsp">&lt;%
        request.setAttribute(&quot;sname&quot;, &quot;虞姬req&quot;);
        request.getRequestDispatcher(&quot;/param/req_scope&quot;).forward(request, response);
%&gt;
</code></pre>
<p>Controller中</p>
<pre><code class="language-java">/**
  * 请求作用域中的参数的传递
  * @return
  */
@RequestMapping(&quot;/req_scope&quot;)
public String requestScopeParamShow(@RequestAttribute String sname, Model model) {
    model.addAttribute(&quot;sname&quot;, sname);
    model.addAttribute(&quot;type&quot;, &quot;请求作用域参数&quot;);
    return &quot;param_show&quot;;
}
</code></pre>
<blockquote>
<p>获取请求作用域中的参数</p>
</blockquote>
<h5 id="sessionattribute">@SessionAttribute</h5>
<blockquote>
<p>获取Session作用域中的参数，用法和上面请求作用域中使用类似</p>
</blockquote>
<h5 id="cookievalue">@CookieValue</h5>
<p>jsp中代码</p>
<pre><code class="language-jsp">cookie参数传递：&lt;br /&gt;
&lt;%
response.addCookie(new Cookie(&quot;sname&quot;, &quot;yuji_cookie&quot;));
%&gt;
&lt;a href=&quot;/param/cookie&quot;&gt;发起请求&lt;/a&gt;
</code></pre>
<p>Controller中</p>
<pre><code class="language-java">/**
  * Cookie中的参数的传递
  * @return
  */
@RequestMapping(&quot;/cookie&quot;)
public String cookieParamShow(@CookieValue String sname, Model model) {
    model.addAttribute(&quot;sname&quot;, sname);
    model.addAttribute(&quot;type&quot;, &quot;cookie参数&quot;);
    return &quot;param_show&quot;;
}
</code></pre>
<blockquote>
<p>获取Cookie中的指定数据</p>
</blockquote>
<blockquote>
<p>上面这几个注解都是用于在方法的参数上标注，用于获取不同种类的参数</p>
</blockquote>
<h4 id="controller中的数据传递到页面">Controller中的数据传递到页面</h4>
<h5 id="model">Model</h5>
<p>handler方法定义：</p>
<pre><code class="language-java">@RequestMapping(&quot;/show_msg&quot;)
public String showMessage(Model model) {
    model.addAttribute(&quot;msg&quot;, &quot;我是通过model传过来的参数&quot;);
    return &quot;message_page&quot;;
}
</code></pre>
<p>message_page.jsp</p>
<pre><code class="language-jsp">&lt;h1&gt;
    获取后台参数： ${msg}
&lt;/h1&gt;
</code></pre>
<h5 id="modelandview">ModelAndView</h5>
<pre><code class="language-java">/**
 * ModelAndView其实是将数据Model和视图View做了一个封装，底层实现原理一样
 */
@RequestMapping(&quot;/show_msg&quot;)
public ModelAndView showMessage(ModelAndView mv) {
    mv.addObject(&quot;msg&quot;, &quot;我是通过model传过来的参数&quot;);
    mv.setViewName(&quot;message_page&quot;);
    return mv;
}
</code></pre>
<blockquote>
<p>Model和ModelAndView传递的参数本质上也是用请求作用域来实现的，所以仅对请求转发有效。</p>
</blockquote>
<h3 id="视图控制器">视图控制器</h3>
<p>用于通过配置的方式简化我们项目中不含业务逻辑的页面跳转，省去了我们写一个空方法的步骤。</p>
<h4 id="视图控制器的作用和用法">视图控制器的作用和用法</h4>
<p>试想一下，如果我们的工程中有这样的一个需求，比如当用户点了某个链接和按钮的时候，我们需要做一个页面跳转，这个跳转的目标可能是一个公开目录的页面也可能是私有目录（/WEB-INF/下）的页面、还可能是跳转到后台Controller的某个方法中，我们如何实现？</p>
<p>示例：比如我们想将登陆页设置为一个项目默认欢迎页面</p>
<p>方案一：在Controller中添加一个拦截/的handler方法</p>
<pre><code class="language-java">@RequestMapping(&quot;/&quot;)
public String toWelcomePage() {
    return &quot;login&quot;;
}
</code></pre>
<p>方法二：使用视图控制器</p>
<p>在dispatcher-servlet.xml（SpringMVC配置文件）配置中添加</p>
<pre><code class="language-xml">&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;login&quot; /&gt;
</code></pre>
<ul>
<li>path: 指定要匹配的访问路径</li>
<li>view-name: 返回的逻辑视图名</li>
<li>status-code: 设置响应状态码。(注：不能通过只设置状态码，不设置view-name实现只返回code，没有页面的处理)</li>
</ul>
<blockquote>
<p>view-name不仅可以是逻辑视图名，还可以添加forward、redirect前缀，通过转发或重定向的方式跳转到一个具体的路径，如：&lt;mvc:view-controller path=&quot;/&quot; view-anme=&quot;forward:/WEB-INF/login.jsp&quot; /&gt;</p>
</blockquote>
<!-- SpringMVC 第二天 -->
<h3 id="设置web项目的默认欢迎页">设置Web项目的默认欢迎页</h3>
<ul>
<li>
<p>在web.xml中使用<welcome-file-list>标签指定</p>
</li>
<li>
<p>使用上面提到的视图控制器</p>
<pre><code class="language-xml">&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;逻辑视图名&quot; /&gt;
&lt;!-- 当工程中存在Tomcat默认欢迎页同名文件时此种方式可能失效，比如index.html、index.jsp、index.htm --&gt;
</code></pre>
</li>
</ul>
<h3 id="静态资源处理">静态资源处理</h3>
<pre><code class="language-xml">&lt;!-- 针对静态资源的处理 --&gt;
    &lt;!-- http://localhost:8080/static/css/index.css --&gt;
&lt;mvc:resources mapping=&quot;/static/**&quot; location=&quot;/static/&quot; /&gt;
</code></pre>
<h3 id="重定向和转发">重定向和转发</h3>
<h4 id="在servlet实现重定向和转发">在Servlet实现重定向和转发：</h4>
<p>重定向：response.sendRedirect(&quot;xxx.jsp&quot;);</p>
<p>转发： request.getRequestDispatcher(&quot;xxx.jsp&quot;).forward(request, response);</p>
<h4 id="在springmvc中">在SpringMVC中</h4>
<h5 id="请求转发有三种方式">请求转发有三种方式</h5>
<ul>
<li>在Handler方法中直接返回逻辑视图名称</li>
<li>在Handler方法中返回&quot;forward:路径&quot;</li>
<li>在Handler方法中返回InternalResourceView对象</li>
</ul>
<blockquote>
<p>其中第二种和第三种作用一样， 都是将路径用请求转发的方式跳转，返回的路径时不经过视图解析器处理的；而第一种虽然也是通过请求转发方式跳转，但是返回值会作为逻辑视图名称，经过视图解析器处理后，才渲染。</p>
</blockquote>
<h5 id="重定向有两种方式">重定向有两种方式</h5>
<ul>
<li>在Handler方法中返回&quot;redirect:路径&quot;</li>
<li>在Handler方法中返回RedirectView对象</li>
</ul>
<blockquote>
<p>这两种方法效果一样。 注意使用重定向的方式跳转页面，Model中的数据就无法带到页面了（因为Model底层也是用请求作用域来传递参数的）。</p>
</blockquote>
<h3 id="restfull服务接口开发">RESTFull服务接口开发</h3>
<p>SpringMVC给我们提供了一系列的注解用于支持RESTFull风格的服务开发</p>
<h4 id="常用restfull注解">常用RESTFull注解</h4>
<ul>
<li>
<p><code>@RestController</code></p>
<p>该注解本身是一个组合注解，由<code>@Controller</code>和<code>@ResponseBody</code>两个注解组成，所以拥有这两个注解的作用。 在类上声明后，该类会变成一个Controller类，同时，方法的返回值会作为响应体经过消息转换器直接响应给客户端，而不会将其作为视图渲染。</p>
<pre><code class="language-java">@RestController // 这个注解其实是组合了下面两个注解的作用
//@Controller
//@ResponseBody
public class UserRestController {

}
</code></pre>
</li>
<li>
<p><code>@GetMapping</code> :</p>
<p>作用： 申明当前handler方法只匹配GET请求</p>
<p>使用示例</p>
<pre><code class="language-java">@GetMapping(&quot;/{id}&quot;)
public User getUserById(@PathVariable Integer id) {
    return userService.findById(id);
}
</code></pre>
</li>
<li>
<p><code>@PostMapping</code>: 申明当前handler方法只匹配POST请求</p>
</li>
<li>
<p><code>@DeleteMapping</code>: 申明当前handler方法只匹配DELETE请求</p>
</li>
<li>
<p><code>@PutMapping</code>: 申明当前handler方法只匹配PUT请求</p>
</li>
</ul>
<blockquote>
<p>上面四个注解分别对应HTTP的一种请求方法，使用方法类似。</p>
</blockquote>
<p>上面四个注解其实是一种快捷注解， 等效于使用下面代码：</p>
<pre><code class="language-java">@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.GET)
@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.POST)
@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.PUT)
@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.DELETE)
</code></pre>
<ul>
<li>@PathVariable: 获取请求地址中的变量，注入到方法参数中</li>
</ul>
<h4 id="返回json格式的数据-消息转换器">返回JSON格式的数据 —— 消息转换器</h4>
<h5 id="消息转换器是什么">消息转换器是什么</h5>
<p>之前我们在写普通Controller时，handler方法的返回值要是就是一个String（逻辑视图名），要么就是一个ModelAndView、View对象。</p>
<p>而我们使用了RestController之后，方法的返回值已经不会被作为视图去渲染了，这时候我们的方法其实可以返回任意类型的数据。这些数据会直接通过响应体以流的方式返回给客户端。</p>
<p>我们知道Java中的对象是不能直接用流的方式读取的，需要序列化。比如我们的handler方法返回了一个User类型，SpringMVC就不知道如果将这个类型返回给客户端了。这时就需要我们通过配置消息转换器来完成这种类型对象的返回处理。 而在RESTFull服务中，对象绝大部分传递方式就是通过JSON格式。</p>
<h5 id="如何配置一个转换json格式的消息转换器">如何配置一个转换JSON格式的消息转换器</h5>
<ul>
<li>
<p>使用SpringMVC默认的Jackson库</p>
<ol>
<li>
<p>引入依赖</p>
<pre><code class="language-xml">&lt;!-- jackson依赖，用于将handler方法返回的对象直接转换成JSON数据 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.9.7&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>开启mvc注解支持</p>
<pre><code class="language-xml">&lt;mvc:annotation-driven /&gt;
</code></pre>
</li>
<li>
<p>定义Controller类</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/user&quot;)
public class UserRestController {
    
    @GetMapping(&quot;/{id}&quot;)
    public User getUserById(Integer id) {
        return userService.findById(id);
    }
    
}
</code></pre>
</li>
</ol>
<blockquote>
<p>Jackson是SpringMVC默认的JSON格式消息转换器， 所以在不配置额外转json参数时，我们可以直接只引入jackson依赖，再开启mvc直接支持就可以了。而第三方的转换库如FastJSON就必须显示配置MessageConverter</p>
</blockquote>
</li>
<li>
<p>使用阿里巴巴的FastJSON库</p>
<ol>
<li>
<p>引入依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
     &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
     &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
     &lt;version&gt;1.2.57&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>配置MessageConverter</p>
<pre><code class="language-xml">&lt;mvc:annotation-driven&gt;
    &lt;mvc:message-converters&gt;
        &lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;&gt;
            &lt;property name=&quot;defaultCharset&quot; value=&quot;UTF-8&quot; /&gt;
            &lt;property name=&quot;fastJsonConfig&quot;&gt;
                &lt;!-- 设置转换JSON的参数 --&gt;
                &lt;bean class=&quot;com.alibaba.fastjson.support.config.FastJsonConfig&quot;&gt;
                    &lt;property name=&quot;dateFormat&quot; value=&quot;yyyy-MM-dd HH:mm:ss&quot; /&gt;
                &lt;/bean&gt;
            &lt;/property&gt;
            &lt;property name=&quot;supportedMediaTypes&quot;&gt;
            &lt;!-- 指定转换完JSON后返回的响应头和编码，添加text/html是为了处理在IE下application/json会弹出下载框问题 --&gt;
                &lt;list&gt;
                    &lt;!--&lt;value&gt;text/html;charset=UTF-8&lt;/value&gt;--&gt;                
                    &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt;
                &lt;/list&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/mvc:message-converters&gt;
&lt;/mvc:annotation-driven&gt;
</code></pre>
</li>
<li>
<p>定义Controller类</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/user&quot;)
public class UserRestController {
    
    @GetMapping(&quot;/{id}&quot;)
    public User getUserById(Integer id) {
        return userService.findById(id);
    }
    
}
</code></pre>
</li>
</ol>
</li>
</ul>
<h4 id="通过网页模拟restfull请求">通过网页模拟RESTFull请求</h4>
<p>通过SpringMVC给我们提供的一个过滤器，我们可以用表单模拟各种RESTFull的请求，使用方法如下：</p>
<ol>
<li>
<p>在web.xml中添加过滤器</p>
<pre><code class="language-xml">&lt;filter&gt;
    &lt;filter-name&gt;httpMethodFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;httpMethodFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
</li>
<li>
<p>在表单中添加name为_method的hidden域，并将表单的method设置为post</p>
<pre><code class="language-html">&lt;!-- 使用表单模拟发起一个DELETE请求，删除user表中id为57的数据 --&gt;
&lt;form action=&quot;/user/57&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;delete&quot; /&gt;
    &lt;input type=&quot;number&quot; name=&quot;id&quot; /&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;
    &lt;input type=&quot;submit&quot; /&gt;
&lt;/form&gt;
</code></pre>
</li>
</ol>
<blockquote>
<p>由于RESTFull请求通常发生在服务于服务之间的调用，所以有些请求用浏览器不太好模拟，建议使用专业的网络测试工具postman来进行测试。</p>
</blockquote>
<h4 id="resttemplate工具类">RestTemplate工具类</h4>
<p>SpringMVC帮我们封装的一个Rest请求工具，可以使用一个URI地址发起网络请求，并且将结果封装成一个指定的对象。</p>
<h3 id="处理请求乱码">处理请求乱码</h3>
<p>SpringMVC给我们提供了一个专门用来解决post请求乱码的过滤器，我们只需将其配置到web.xml中，就可以避免post请求乱码，免去了我们自己写过滤器的麻烦</p>
<p>在web.xml中</p>
<pre><code class="language-xml">&lt;!-- 解决POST请求乱码 --&gt;
&lt;filter&gt;
    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;forceEncoding&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<blockquote>
<p>注意： 如果项目中配置了多个过滤器，建议将此过滤器放到所有过滤器的最上面。</p>
</blockquote>
<h3 id="在springmvc方法中支持的参数">在SpringMVC方法中支持的参数</h3>
<p>SpringMVC的handler方法中支持诸如很多特殊类型的参数，常用的有</p>
<h5 id="注入原生servlet对象">注入原生Servlet对象</h5>
<ul>
<li>javax.servlet.ServletRequest</li>
<li>javax.servlet.ServletResponse</li>
<li>javax.serlvet.http.HttpSession</li>
</ul>
<h5 id="以流的方式读取请求体-以流的方式响应到客户端">以流的方式读取请求体、以流的方式响应到客户端</h5>
<ul>
<li><s>java.io.InputStream、java.io.Reader</s></li>
<li><s>java.io.OutputStream、java.io.Writer</s></li>
</ul>
<h5 id="读取请求体和请求头数据">读取请求体和请求头数据</h5>
<ul>
<li>HttpEntity</li>
</ul>
<h5 id="向页面传参">向页面传参</h5>
<ul>
<li>java.util.Map，org.springframework.ui.Model、org.springframework.ui.ModelMap</li>
</ul>
<!-- SpringMVC 第三天 -->
<h3 id="文件上传">文件上传</h3>
<h4 id="说明">说明</h4>
<p>在Java中，主流的文件上传方式有两种，分别是通用文件上传(commons-fileupload)和Servlet3.0方式的文件上传。SpringMVC分别对着两种方式都做了支持。</p>
<ul>
<li>CommonsMultipartResolver</li>
<li>StandardServletMultipartResolver</li>
</ul>
<blockquote>
<p>除此之外SpringMVC对文件上传的接口做了统一的封装，使用<code>MultipartFile</code>接口代替了通用上传中的<code>FileItem</code>和Servlet3.0中的<code>Part</code>，使得开发人员在业务代码中可以使用统一的接口处理，而不用管底层用的是哪种文件上传实现方式。</p>
</blockquote>
<h4 id="基于apache-fileupload通用文件上传包">基于Apache Fileupload通用文件上传包</h4>
<ol>
<li>
<p>添加依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
    &lt;version&gt;1.4&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-io&lt;/groupId&gt;
    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
    &lt;version&gt;2.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>在SpringMVC配置文件中添加MultipartResolver文件上传解析器</p>
<pre><code class="language-xml">&lt;!-- 配置基于apache fileupload的通用文件上传器（注意：id属性不可省略） --&gt;
&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
    &lt;!-- 指定文件上传编码 --&gt;
    &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot; /&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>在Controller中编写文件上传逻辑代码</p>
<pre><code class="language-java">@RequestMapping(&quot;/upload&quot;)
public String upload(@RequestParam(&quot;myFile&quot;) MultipartFile file, HttpServletRequest req, Model model) {
    try {
        // 使用SpringMVC给我们提供的工具类获取项目中upload文件夹在硬盘上的绝对路径
        String uploadPath = WebUtils.getRealPath(req.getServletContext(), &quot;/upload/&quot;);
        // 将上传的文件写到上传目录
        file.transferTo(new File(uploadPath+file.getOriginalFilename()));
    } catch (IOException e) {
        e.printStackTrace();
    }
}
</code></pre>
</li>
</ol>
<h4 id="基于servlet30标准api文件上传">基于Servlet3.0标准API文件上传</h4>
<ol>
<li>
<p>开启Servlet文件上传支持</p>
<p>web.xml</p>
<pre><code class="language-xml">&lt;servlet&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!-- 开启Servlet文件上传支持 --&gt;
    &lt;multipart-config /&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
</li>
<li>
<p>在SpringMVC中配置MultipartResolver</p>
<pre><code class="language-xml">&lt;!-- 配置基于Servlet3.0文件上传器（注意：id属性不可省略） --&gt;
&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.support.StandardServletMultipartResolver&quot; /&gt;
</code></pre>
</li>
<li>
<p>在Controller中编写文件上传逻辑代码</p>
<blockquote>
<p>实现方式同通用上传代码一样。</p>
</blockquote>
</li>
</ol>
<h4 id="文件名上传乱码问题">文件名上传乱码问题</h4>
<ul>
<li>
<p>使用通用上传方式的解决方法</p>
<p>在配置的CommonsMultipartResolver bean中注入属性</p>
<pre><code class="language-xml">&lt;!-- 配置基于apache fileupload的通用文件上传器（注意：id属性不可省略） --&gt;
&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
    &lt;!-- 指定文件上传编码 --&gt;
    &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot; /&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>使用Servlet3.0标准上传方式的解决方法</p>
<p>通过配置SpringMVC提供的编码过滤器解决</p>
<p>web.xml</p>
<pre><code class="language-xml">&lt;filter&gt;
    &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;forceEncoding&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<blockquote>
<p>本质上还是设置请求的编码 request.setCharacterEncoding(&quot;UTF-8&quot;);</p>
</blockquote>
</li>
</ul>
<h3 id="拦截器">拦截器</h3>
<h4 id="拦截器-vs-过滤器">拦截器 VS 过滤器</h4>
<p>过滤器是Servlet规范中提供的一项技术。不依赖于任何第三方框架。它的作用主要用来做两件事： 加工请求、过滤请求。</p>
<p>拦截器是SpringMVC自己封装的一项基于Handler拦截的结束。也就是说只有在SpringMVC框架里面才有拦截器的概念。拦截器拦截的对象是Handler。它的全称是 HandlerInterceptor。</p>
<p>加上拦截器以后，请求处理流程：  request -&gt; DispatcherServlet -&gt; HandlerMapping -&gt; HandlerExecutionChain(包含了目标handler和若干个拦截器) -&gt; HandlerAdapter -&gt; 循环调用HandlerExecutionChain对象中所有拦截器的prehandler方法 -&gt; 如果preHandler返回false，那么handler将不会被调用。反之，才会正常调用。</p>
<h4 id="如何使用拦截器">如何使用拦截器</h4>
<h5 id="定义拦截器类">定义拦截器类</h5>
<p>新建一个类实现HandlerInterceptor接口</p>
<pre><code class="language-java">/**
 * 定义拦截器步骤：
 *      1. 定义一个普通类，实现HandlerInterceptor接口
 *      2. 按需实现接口中的方法
 *      3. 在SpringMVC配置文件中通过&lt;mvc:interceptors&gt;&lt;/mvc:interceptors&gt;配置拦截器
 */
public class NotAllowedInterceptor implements HandlerInterceptor {

    /**
     * 此回调方法在执行Handler之前被调用
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println(&quot;进入NotAllowedInterceptor, 凡是我能拦截到的请求，一律不准通过!&quot;);
        return false;
    }

    /**
     * 此回调方法在执行Handler之后被调用
     * @param request
     * @param response
     * @param handler
     * @param modelAndView
     * @throws Exception
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {

    }

    /**
     * 此回调方法在DispatcherServlet最终响应之前被调用
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {

    }
}
</code></pre>
<h5 id="配置拦截器">配置拦截器</h5>
<h6 id="全局拦截器">全局拦截器</h6>
<pre><code class="language-xml">&lt;mvc:interceptors&gt;
    &lt;!-- 这种方式配置的拦截器会拦截所有请求 --&gt;
    &lt;bean class=&quot;com.lanou3g.springmvc.interceptor.NotAllowedInterceptor&quot; /&gt;
&lt;/mvc:interceptors&gt;
</code></pre>
<h6 id="拦截指定请求的拦截器">拦截指定请求的拦截器</h6>
<pre><code class="language-xml">&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;!-- 拦截的请求 --&gt;
        &lt;mvc:mapping path=&quot;/admin/**&quot; /&gt;
        &lt;!-- 不拦截的请求 --&gt;
        &lt;mvc:exclude-mapping path=&quot;/intercepor/**&quot;/&gt;
        &lt;!-- 配置我们定义的实现了HandlerInterceptor接口的类 --&gt;
        &lt;bean class=&quot;com.lanou3g.springmvc.interceptor.NotAllowedInterceptor&quot; /&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[三大框架整合]]></title>
        <id>https://klein-moretti.github.io/post/san-da-kuang-jia-zheng-he</id>
        <link href="https://klein-moretti.github.io/post/san-da-kuang-jia-zheng-he">
        </link>
        <updated>2018-05-13T14:55:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="ssm整合步骤">SSM整合步骤</h1>
<h2 id="spring和mybatis整合">Spring和Mybatis整合</h2>
<ol>
<li>
<p>加入Spring、mybatis的依赖</p>
<pre><code class="language-xml">&lt;!-- Spring相关依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- mybatis相关依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
    &lt;version&gt;3.4.6&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- Spring、Mybatis整合依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;version&gt;1.3.2&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- mysql驱动 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;5.1.47&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>在Spring bean配置文件中，配置整合的Bean</p>
<p>在类路径下新建applicationContext.xml文件，做如下配置：</p>
<ol>
<li>
<p>配置数据源</p>
<pre><code class="language-xml">&lt;context:property-placeholder location=&quot;classpath*:/jdbc.properties&quot; /&gt;
&lt;!-- 连接池 --&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;
    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;
    &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;
    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>配置SqlSessionFactoryBean</p>
<pre><code class="language-xml">&lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
    &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.lanou3g.ssm.bean&quot; /&gt;
    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:/mybatis/mappers/*.xml&quot; /&gt;
&lt;/bean&gt;
</code></pre>
</li>
</ol>
</li>
<li>
<p>编写mybatis的mapper映射文件、mapper接口、核心配置文件(可选)</p>
<blockquote>
<p>mapper映射文件和mapper接口可直接用mybatis逆向工程生成</p>
</blockquote>
</li>
<li>
<p>配置扫描包路径</p>
<pre><code class="language-xml">&lt;context:component-scan base-package=&quot;com.lanou3g.ssm.service&quot;  /&gt;
</code></pre>
</li>
<li>
<p>配置mapper接口扫描路径</p>
<pre><code class="language-xml">&lt;mybatis:scan base-package=&quot;com.lanou3g.ssm.mapper&quot; /&gt;
</code></pre>
<blockquote>
<p>作用是让mybatis去指定的包下找Mapper接口，生成实现类，注入到IOC容器中</p>
</blockquote>
</li>
</ol>
<h2 id="spring和springmvc">Spring和SpringMVC</h2>
<ol>
<li>
<p>添加SpringMVC依赖和Servlet、JSTL依赖</p>
<pre><code class="language-xml">&lt;!-- SpringMVC依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- Servlet api 依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
    &lt;version&gt;3.1.0&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;jstl&lt;/artifactId&gt;
    &lt;version&gt;1.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>配置SpringMVC</p>
<p>web.xml</p>
<pre><code class="language-xml">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee
                      http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot;&gt;

  &lt;!-- 配置root applicationContext --&gt;
  &lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;classpath*:application*.xml&lt;/param-value&gt;
  &lt;/context-param&gt;

  &lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
  &lt;/listener&gt;

  &lt;!-- 配置请求编码 --&gt;
  &lt;filter&gt;
    &lt;filter-name&gt;charchaterFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;encoding&lt;/param-name&gt;
      &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
  &lt;/filter&gt;
  &lt;filter-mapping&gt;
    &lt;filter-name&gt;charchaterFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;

  &lt;!-- 配置DispatcherServlet大总管 --&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;

&lt;/web-app&gt;
</code></pre>
<p>dispatcher-servlet.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!-- 配置扫描Controller的包路径 --&gt;
    &lt;context:component-scan base-package=&quot;com.lanou3g.ssm.web&quot; /&gt;

    &lt;!-- 配置视图解析器 --&gt;
    &lt;mvc:view-resolvers&gt;
        &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
            &lt;property name=&quot;prefix&quot; value=&quot;/&quot; /&gt;
            &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
        &lt;/bean&gt;
    &lt;/mvc:view-resolvers&gt;

    &lt;!-- 开启SpringMVC注解支持 --&gt;
    &lt;mvc:annotation-driven&gt;
        &lt;!-- 配置消息转换器，将REST返回的对象类型转成JSON --&gt;
        &lt;mvc:message-converters&gt;
            &lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;&gt;
                &lt;property name=&quot;defaultCharset&quot; value=&quot;UTF-8&quot; /&gt;
                &lt;property name=&quot;supportedMediaTypes&quot;&gt;
                    &lt;list&gt;
                        &lt;!-- 这里配置的text/html主要是解决IE浏览器请求JSON会弹出下载框的问题 --&gt;
                        &lt;value&gt;text/html&lt;/value&gt;
                        &lt;value&gt;application/json&lt;/value&gt;
                    &lt;/list&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/mvc:message-converters&gt;
    &lt;/mvc:annotation-driven&gt;

    &lt;!-- 静态资源放行 --&gt;
    &lt;mvc:resources mapping=&quot;/static/**&quot; location=&quot;/static/&quot; /&gt;
&lt;/beans&gt;
</code></pre>
</li>
</ol>
<p>至此，SSM三个框架就整合完成了。 可以编写自己的service代码和controller层代码。放一个项目目录结构图</p>
<figure data-type="image" tabindex="1"><img src="https://klein-moretti.github.io/post-images/1576061791471.png" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据分页]]></title>
        <id>https://klein-moretti.github.io/post/shu-ju-fen-ye</id>
        <link href="https://klein-moretti.github.io/post/shu-ju-fen-ye">
        </link>
        <updated>2017-11-05T11:58:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="数据分页">数据分页</h1>
<h2 id="核心参数">核心参数</h2>
<ul>
<li>总数据条数
<ul>
<li>来源： 后台自己从数据库中查询而来</li>
</ul>
</li>
<li>每页展示条数(pageSize)
<ul>
<li>来源：从前端页面传递过来</li>
</ul>
</li>
<li>总页数（计算得知）
<ul>
<li>来源： 根据总条数和每页展示数量计算得来</li>
</ul>
</li>
<li>当前展示的页码（currentPage)
<ul>
<li>来源：从前端页面传递过来</li>
</ul>
</li>
<li>每页要展示的数据本身
<ul>
<li>来源：后台自己从数据库中查询而来</li>
</ul>
</li>
</ul>
<h2 id="物理分页">物理分页</h2>
<h3 id="概述">概述</h3>
<p>所谓的物理分页其实就是直接通过数据库来实现返回一部分数据。每次只从数据库中查询一页的数据。与之相对应的还有逻辑分页。</p>
<h3 id="mysql中实现语句">Mysql中实现语句</h3>
<pre><code class="language-sql">    SELECT * FROM `shop` LIMIT (currentPage-1)*pageSize, pageSize;
</code></pre>
<h2 id="逻辑分页">逻辑分页</h2>
<p>所谓的逻辑分页其实就是通过内存来进行分页。具体来说，首次查询数据时，将所有数据都取出放到内存中，展示其他页的数据时，在内存中实现数据的截取，展示。</p>
<h2 id="两种分页的对比">两种分页的对比</h2>
<ol>
<li>物理分页节约内存空间，效率相比逻辑分页理论上效率低一些。试用场景：数据量大的时候。</li>
<li>逻辑分页占用空间大，理论上分页性能高一些。试用场景：数据量小，访问用户多。要处理缓存数据同步的问题。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[文件上传]]></title>
        <id>https://klein-moretti.github.io/post/wen-jian-shang-chuan</id>
        <link href="https://klein-moretti.github.io/post/wen-jian-shang-chuan">
        </link>
        <updated>2017-10-17T10:14:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="文件上传">文件上传</h1>
<h2 id="前端页面">前端页面</h2>
<h3 id="必要条件">必要条件</h3>
<ol>
<li>需要有一个form表单</li>
<li>form表单需要设置以下几个属性：
<ol>
<li>action:  提交数据的目的地</li>
<li>method: 设置post</li>
<li>enctype: 设置成multipart/form-data</li>
</ol>
</li>
<li>form里需要至少有一个file域： &lt;input type=&quot;file&quot; name=&quot;xxx&quot; /&gt;</li>
</ol>
<h2 id="后端技术">后端技术</h2>
<p>所谓文件上传其实就是用流的方式，将文件从客户的电脑上通过网页中的表单， 以二进制流的方式，流到服务器的过程。</p>
<p>文件下载就是反过来， 将文件从服务器上通过二进制流的方式流到客户电脑上。</p>
<h3 id="servlet30上传方式">Servlet3.0上传方式</h3>
<h4 id="servlet30上传的核心-一个注解-一个接口">Servlet3.0上传的核心： 一个注解、一个接口</h4>
<p>注解：</p>
<p>@MultipartConfig： 开启Servlet文件上传功能</p>
<p>接口：</p>
<p>javax.servlet.http.Part：  封装了上传的文件相关的所有信息</p>
<h4 id="具体操作步骤">具体操作步骤</h4>
<ol>
<li>新建处理文件上传的Servlet，然后重写doPost方法</li>
<li>给Servlet添加@MultipartConfig注解，开启文件上传功能</li>
<li>Part part = request.getPart(&quot;input type='type' name的值&quot;);</li>
<li>part对象有两个作用：
<ol>
<li>可以获取到上传文件的所有信息，比如：文件名、大小、类型、文件流数据</li>
<li>可以直接将文件写到服务器   part.write(&quot;文件保存的路径&quot;);</li>
</ol>
</li>
</ol>
<h3 id="apache-commons-fileupload-上传方式">Apache Commons Fileupload 上传方式</h3>
<h4 id="用fileupload上传的核心就是一个接口-两个类">用fileupload上传的核心就是：一个接口、两个类</h4>
<p>接口： FileItem</p>
<p>封装了我们表单中的每个域的数据（可能是普通文本数据，也可能是上传的文件）</p>
<p>类：</p>
<p>DiskFileItemFactory：  用于创建文件上传对象的工厂</p>
<p>ServletFileupload： 文件上传对象</p>
<h4 id="具体操作步骤-2">具体操作步骤</h4>
<ol>
<li>
<p>需要添加依赖： commons-fileupload.jar、commons-io.jar</p>
</li>
<li>
<p>新建处理文件上传的Servlet，然后重写doPost方法</p>
</li>
<li>
<p>调用ServletFileupload对象的静态方法，判断请求是否是一个文件上传请求</p>
<pre><code class="language-java">if(!ServletFileupload.isMultipartContent(request)) {
    // 如果不是multipart请求，代表不是一个有效的文件上传请求， 下面的步骤都可以省略了
}
</code></pre>
</li>
<li>
<p>创建文件上传工厂对象：</p>
<pre><code class="language-java">DiskFileItemFactory factory = new DiskFileItemFactory();
// factory.set.... 可以设置相关参数
</code></pre>
</li>
<li>
<p>创建文件上传对象</p>
<pre><code class="language-java">ServletFileupload upload = new ServletFileupload(factory);
// upload.set.... 可以设置相关参数
</code></pre>
</li>
<li>
<p>用文件上传对象解析请求对象，然后获取解析后的所有FileItem</p>
<pre><code class="language-java">List&lt;FileItem&gt; fileItems = upload.parseRequest(request);
</code></pre>
</li>
<li>
<p>迭代处理每个FileItem</p>
<ol>
<li>文本信息的FileItem获取后进行相关的业务操作</li>
<li>文件类型的FileItem获取后，调用FileItem.write将文件写到服务器某个目录下。</li>
</ol>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Cookie&Session 总结]]></title>
        <id>https://klein-moretti.github.io/post/cookieandsession-zong-jie</id>
        <link href="https://klein-moretti.github.io/post/cookieandsession-zong-jie">
        </link>
        <updated>2017-08-17T10:52:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="cookiesession">Cookie&amp;Session</h1>
<h2 id="cookie">Cookie</h2>
<h3 id="cookie是什么-what">Cookie是什么？ （What）</h3>
<p>Cookie是一项在Web请求中，基于客户端的用于存储数据的技术。</p>
<h3 id="为什么要用cookiewhy">为什么要用Cookie？（Why)</h3>
<p>我们知道HTTP协议是一种无状态协议，服务端无法区分每个请求对应的是哪个用户。 Cookie就是为了解决这个问题而生的，它通过在浏览器端存储一些数据，在请求时附加到请求头中，这样服务端一读取请求头就知道了这次请求是哪个用户发起的。</p>
<h3 id="什么情况下要使用cookiewhen">什么情况下要使用Cookie?(When)</h3>
<p>Cookie的使用分为在业务程序中显式使用和通过容器隐式使用。</p>
<ul>
<li>隐式使用： 首次访问JSP、Servlet时，Servlet容器会自动往响应头中添加一个Cookie(Tomcat中是JSESSIONID)</li>
<li>显式使用： 当我们有一些安全性要求不高，数据量不大的用户数据需要存储时，可以考虑使用Cookie</li>
</ul>
<h3 id="怎么使用cookiehow">怎么使用Cookie?（How)</h3>
<h4 id="cookie的创建">Cookie的创建</h4>
<pre><code class="language-java">// 两种方法
// 1. 构造时将数据传入
Cookie cookie = new Cookie(&quot;key&quot;, &quot;value&quot;);

// 2. 构造时无参，然后通过set方法设置数据
Cookie cookie = new Cookie();
cookie.setName(&quot;key&quot;);
cookie.setValue(&quot;value&quot;);


// 除了核心的数据之外，我们还可以设置一些其他属性
// 1. 设置过期时间
cookie.setMaxAge(60);	//单位：秒(60秒后,Cookie会自动删除)
// 2. 设置Domain
cookie.setDomain(&quot;www.baidu.com&quot;); // 代表只有访问www.baidu.com这个域名下的请求，才能获取到此Cookie
cookie.setDomain(&quot;.baidu.com&quot;);	// 代表所有www.baidu.com下的二级域名包括www.baidu.com这个一级域名都可以共享此Cookie（注意这种情况下domain必须以&quot;.&quot;开头）
// 3. 设置Path 
cookie.setPath(&quot;/StudentServlet&quot;);	// 一旦设置了Path，那么要获取Cookie，当前的请求地址必须满足Path的规则，否则获取不到此Cookie     http://xxx:port/student/StudentServlet/getstu/3
</code></pre>
<h4 id="cookie的添加">Cookie的添加</h4>
<pre><code class="language-java">// 使用响应对象写入浏览器

reponse.addCookie(cookie); //本质上会在响应中添加一个Set-Cookie响应头。
</code></pre>
<h4 id="cookie删除">Cookie删除</h4>
<pre><code class="language-java">// Cookie没有delete方法

// 我们可以通过设置过期时间为0实现删除
cookie.setMaxAge(0);
response.addCookie(cookie);
</code></pre>
<h4 id="cookie的修改">Cookie的修改</h4>
<pre><code class="language-java">// Cookie的修改其实就是覆盖添加

// 具体来说分三步
// 1. 先获取已有Cookie，
// 2. 然后修改其中的数据，
// 3. 最后调用response.addCookie()重新添加到浏览器，浏览器看到Key相同的Cookie会自动更新

</code></pre>
<h4 id="获取cookie中的数据">获取Cookie中的数据</h4>
<pre><code class="language-java">// 1. 先通过请求对象获取请求中携带的所有Cookie数组
Cookie[] cookies = request.getCookies();

// 2. 迭代Cookie数组，寻找要操作的Cookie
for(Cookie cookie : cookies) {
    // 根据cookie.getName()判断是否是自己要获取数据的cookie
	
    // 3. 找到后，调用cookie.getValue()获取数据
}
</code></pre>
<h2 id="session">Session</h2>
<h3 id="session是什么-what">Session是什么？ （What）</h3>
<p>Session和Cookie类似，都是用来存储用户信息的。不同于Cookie的是Session是存储在服务器端。他们两者通过JSESSIONID关联起来。</p>
<h3 id="为什么要用sessionwhy">为什么要用Session？（Why)</h3>
<p>虽然Cookie已经可以标识出哪个请求是属于哪个用户的。但是不足的是Cookie本身是存储于客户端硬盘上，安全性不高，不适合存储敏感数据，还有Cookie本身能存储的数据很有限（数据大小本身限制、数据类型限制、字符集限制）。而存储在服务端的Session完全没有这些问题。</p>
<h3 id="什么情况下要使用sessionwhen">什么情况下要使用Session?(When)</h3>
<p>Session可以用来存储用户的所有信息，理论上所有能在Cookie中存储的数据都可以放到Session中。考虑到Session是基于内存的，如果存储太多不太重要的数据会大大增加服务器端内存压力，一般Session会配合Cookie一起使用。</p>
<h3 id="怎么使用sessionhow">怎么使用Session?（How)</h3>
<h4 id="创建session">创建Session</h4>
<pre><code class="language-java">// Session是由容器自动创建的，我们可以在代码中直接获取Sesssion

HttpSession session = request.getSession();
</code></pre>
<h4 id="往session中存储数据">往Session中存储数据</h4>
<pre><code class="language-java">session.setAttribute();
</code></pre>
<h4 id="获取session中的数据">获取Session中的数据</h4>
<pre><code class="language-java">session.getAttribute();
</code></pre>
<h4 id="删除session中的数据">删除Session中的数据</h4>
<pre><code class="language-java">session.removeAttribute();
</code></pre>
<h4 id="修改session中的数据">修改Session中的数据</h4>
<pre><code class="language-java">// 修改Session中的数据和修改Cookie中的数据类似，都是覆盖添加

// 1. 获取要修改的数据
Object data = session.getAttribute(&quot;key&quot;);

// 2. 修改数据对应的属性
data.setXXX();

// 3. 将修改后的数据重新存入Session
session.setAttribute(&quot;key&quot;, data);

</code></pre>
<h4 id="强制让session失效">强制让Session失效</h4>
<pre><code class="language-java">session.invalidate();	//调用后session对象会失效，同时客户端Cookie中的JSESSIONID也会发生变化
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[集合总结]]></title>
        <id>https://klein-moretti.github.io/post/ji-he-zong-jie</id>
        <link href="https://klein-moretti.github.io/post/ji-he-zong-jie">
        </link>
        <updated>2017-06-25T02:07:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="集合框架">集合框架</h1>
<p>集合：简单的说，集合就是一种容器。</p>
<p>集合作为一种容器，里面可以存放内容，存放的每个内容称为是<strong>元素</strong>（element）。</p>
<p>在整个集合框架里一共有2个大类容器：Collection和Map</p>
<h2 id="collection容器interface">Collection容器（interface）</h2>
<p>Collection是元素类容器的根<strong>接口</strong>。</p>
<h4 id="什么是容器">什么是容器</h4>
<p>容器是一个用于存放东西的物件。</p>
<h4 id="容器应该具备什么功能呢什么样的物件叫容器">容器应该具备什么功能呢？（什么样的物件叫容器）</h4>
<ol>
<li>
<p>可以存东西</p>
<p><strong>add(E element)</strong>  //往容器里添加一个元素。元素可以是任意类型（整数，字符串，自定义类，容器）</p>
<p>addAll(Collection c) //往容器里添加多个元素。参数是一个容器，这个方法会把容器里的元素逐一添加进来</p>
</li>
<li>
<p>查看</p>
<p><strong>size()</strong>  //查看容器中包含多少元素</p>
<p><strong>contains(Object o)</strong> //查看是否包含某个元素</p>
<p>containsAll(Collection c) //查看是否包含某些元素</p>
<p>isEmpty() //是不是一个空容器</p>
</li>
<li>
<p>可以提取(删除)东西</p>
<p>clear()  //清空容器</p>
<p><strong>remove(Object o)</strong> //移除一个元素</p>
<p>removeAll(Collection c) //移除参数容器中包含的元素</p>
</li>
<li>
<p>其他</p>
<p>equals(Collection c) //判断是否个另外一个容器相等。</p>
<p>toArray() //把容器转换为数组</p>
</li>
</ol>
<h3 id="listinterface">List（interface）</h3>
<p>list的英文含义是：列表。</p>
<p>list用于定义什么是有序容器。有序容器是容器的一种。</p>
<p>List是一个接口，它有一个父接口Collection。<strong>List相比于Collection多了下标的概念</strong>。用标可以去访问元素。</p>
<p>围绕下标提供了一堆方法：</p>
<ol>
<li>
<p>添加元素</p>
<p><strong>add(int index, E element)</strong> //在指定的位置添加一个元素<br>
addAll(int index, Collection c) //在指定的位置添加多个元素</p>
<p>删除元素</p>
<p><strong>remove(int index)</strong> //移除指定位置的元素</p>
</li>
<li>
<p>获得子列表</p>
<p>subList(int fromIndex, int toIndex) //获取一个子列表  [formIndex, toIndex)</p>
</li>
<li>
<p>更新元素</p>
<p>set(int index, E element)// 把指定下标的元素更新为指定内容</p>
</li>
<li>
<p>获取元素的位置</p>
<p>indexOf(Object o) //获取指定元素的下标（正着查）</p>
<p>lastIndexOf(Object o)//获取指定元素的下标（倒着查）</p>
<p><strong>get(int index)</strong> //获取指定下标的元素</p>
</li>
</ol>
<h3 id="list的实现类">List的实现类</h3>
<h4 id="arraylist">ArrayList</h4>
<p>ArrayList是List的实现类。既然是实现类，说明ArrayList实现了List中定义的所有方法。</p>
<ol>
<li>
<p>如何创建一个ArrayList对象</p>
<p>ArrayList()   //创建一个初始容量为10的列表。列表里尚未存放任何元素。</p>
<p>ArrayList(int capacity) //创建一个指定初始容量的列表。列表里尚未存放任何元素</p>
<blockquote>
<p>初始容量: 列表刚创建时给定的容量。</p>
<p>Collection是个容器，这个容器与之前学过的数组不同，数组是定长的容器，不能减少容量也不能增加容量。但是Collection是一个变长的容器，空间不够的时候可以扩容。</p>
</blockquote>
<p>ArrayList(Collection c) //创建一个包含参数中全部元素的列表。</p>
</li>
<li>
<p>ArrayList的使用</p>
<p>增删改查（API参考 List）</p>
</li>
</ol>
<blockquote>
<p>在创建ArrayList的时候必须指定元素的类型。例如：ArrayList<String></p>
<p>一旦指定ArrayList存放什么类型的数据，以后取元素的时候，无需进行类型转换。</p>
</blockquote>
<ol start="3">
<li>
<p>遍历ArrayList</p>
<p>假定ArrayList内容如下：</p>
</li>
</ol>
<pre><code class="language-java">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
list.add(&quot;张三&quot;);
list.add(&quot;李四&quot;);
list.add(&quot;王五&quot;);
list.add(&quot;赵六&quot;);
</code></pre>
<p>遍历ArrayList的方法有很多，常用方式如下：</p>
<p>一、使用for循环遍历</p>
<pre><code class="language-java">for(int i = 0; i &lt; list.size(); i++){
  String str = list.get(i);
  System.out.println(str);
}
</code></pre>
<blockquote>
<p>使用list.size()获取元素个数， 从下标0开始循环到结束。通过list.get(i) 获取每个元素，达到遍历的效果。</p>
</blockquote>
<p><strong>二、使用迭代器遍历（推荐）</strong></p>
<pre><code class="language-java">Iterator&lt;String&gt; it = list.iterator();//获取迭代器（迭代器会包含list中所有的元素）
while(it.hasNext()){
    String str = it.next();//获取迭代器中的元素，next执行完，迭代器会指向下一个元素。
    System.out.println(str);
}
</code></pre>
<blockquote>
<p>Iterator是一个接口，规定了迭代器应该具有什么功能（hasNext(), next(), remove()）。</p>
<p>hasNext()方法：用于查看是否还有元素。如果迭代器中还有元素，返回true，如果没有元素了，返回false。</p>
<p>next()：获取当前迭代的元素，迭代器指向下一个元素。</p>
<p>remove(): 删除当前迭代到的元素。</p>
</blockquote>
<p>三、使用for..each遍历元素</p>
<pre><code class="language-java">for(String str : list){
    System.out.println(str);//str就是被遍历到的元素。
}
</code></pre>
<blockquote>
<p>for...each是for循环的增强版，有些语言叫for..in</p>
<p>for...each的本质是通过迭代器遍历元素。可通过XJad反编译工具反编译.class文件查看源码。</p>
</blockquote>
<h4 id="arraylist的优势和劣势">ArrayList的优势和劣势</h4>
<p>ArrayList的底层实现是数组，数组最大特点：数据的内存空间是连续的，所以根据下标查找元素是非常非常快。</p>
<p>弊端增加和删除慢，如果要删除下标为0的元素，实际上是通过循环，把下标为1的赋值给下标为0，把下标为2的赋值给下标为1的，以此类推，直到所有元素位置正确。</p>
<p>如果要在下标为0的位置添加一个元素，它也是通过循环实现的，最大下标的元素赋值给最大下标加1的位置，第2大的下标的元素赋值给最大下标，以此类推第0个元素赋值给第1个元素，新元素覆盖下标为0的元素。</p>
<h3 id="list的另外一个实现类-linkedlist">List的另外一个实现类 LinkedList</h3>
<p>LinkedList使用方式同ArrayList。</p>
<p>LinkedList与ArrayList不同，LinkedList底层靠的是双向链表在存储数据。</p>
<p>链表的特点：增删快，查询慢（需要遍历）。</p>
<h3 id="list的另外一个实现类-vector">List的另外一个实现类 Vector</h3>
<p>实现方式和ArrayList几乎一模一样，Vector所有的方法是线程安全的。在线程里，如果不同的线程在访问同一个List（Vector），不会出现数据紊乱（内部加了锁，一个方法执行的时候，其他的方法等待，执行完以后，其他方法才开始执行）。因为考虑的安全性，不断的加锁和解锁，所以效率很低，速度很慢。</p>
<h3 id="如何选择使用哪个list实现类">如何选择使用哪个List实现类？</h3>
<ol>
<li>
<p>看是否在多线程环境下访问。</p>
<p>是：Vector</p>
<p>否：转到2</p>
</li>
<li>
<p>看增删多还是查询多？</p>
<p>增删多：LinkedList</p>
<p>查询多：ArrayList</p>
<p>不知道：ArrayList</p>
</li>
</ol>
<p>List<Type> list = new   xxxx<Type>()<br>
;</p>
<h3 id="setinterface">Set(interface)</h3>
<p>set是一个接口，<strong>用于描述一个元素不重复的容器</strong>。set里面的重复元素只会出现一次。</p>
<p>首先set是一个容器，既然是容器，那么容器所应该具有的功能它都有。也就说Collection接口中定义的方法，Set里都要有。</p>
<p>通过查阅API，发现Set没有自己独有的方法，Set里所有的方法来自于Collection。</p>
<h3 id="set的实现类">Set的实现类</h3>
<h4 id="hashset-普通set">HashSet （普通set）</h4>
<p>HashSet的特点：</p>
<ol>
<li>不重复</li>
<li>无序</li>
</ol>
<blockquote>
<p>注意：如果要往HashSet中添加自定义类型的数据，你需要给自定义的类添加equals方法，HashSet在添加元素的时候，会拿现有元素逐一和要添加的元素比较（用equals比较），如果相等了，就不添加，比较一遍之后没有相等的，把元素加进来。</p>
</blockquote>
<h4 id="hashset的创建">HashSet的创建</h4>
<ol>
<li>
<p>HashSet() //创建一个空的Set，初始容量为16</p>
</li>
<li>
<p>HashSet(int capacity) //创建一个空的Set，初始容量为指定的容量。</p>
</li>
<li>
<p>HashSet(Collection c) //创建一set，初始内容是c中的元素（会去重）。</p>
</li>
</ol>
<p>HashSet的添加和删除元素API见Set</p>
<blockquote>
<p>HashSet没有获取元素的方法，也没有设置元素的方法。</p>
<p>如何取元素呢？---通过遍历来读取。</p>
</blockquote>
<p>思考？</p>
<p>能否使用for循环遍历Set？-----不能！因为没有下标</p>
<h4 id="hashset的遍历">HashSet的遍历</h4>
<p>假定有如下Set：</p>
<pre><code class="language-java">Set&lt;String&gt; s = new HashSet&lt;&gt;();
s.add(&quot;zhangsan&quot;);
s.add(&quot;lisi&quot;);
s.add(&quot;wangwu&quot;);
s.add(&quot;zhaoliu&quot;);
</code></pre>
<ol>
<li>
<p>使用for..each遍历</p>
<pre><code class="language-java">for(String str : s){
    System.out.println(str);//str就是我们set中每个元素
}
</code></pre>
</li>
<li>
<p>使用Iterator遍历</p>
<pre><code class="language-java">Iterator&lt;String&gt; it = s.iterator();
while(it.hasNext()){
  String str = it.next();
  System.out.println(str);
}
</code></pre>
</li>
</ol>
<h4 id="set另外一个实现类-linkedhashset">Set另外一个实现类 LinkedHashSet</h4>
<p>LinkedHashSet是一个有序的不重复的容器。</p>
<p>特点如下：</p>
<ol>
<li>有序（存放顺序有序）</li>
<li>不重复</li>
</ol>
<h3 id="小节">小节</h3>
<p>Collection是什么？</p>
<p>答：它是一个接口。用来描述容器应该具有哪些功能。（add,addAll,clear,remove,contains,size,iterator）</p>
<p>List是什么？</p>
<p>答：它是一个接口,这个接口继承了Colletion。用来描述一个有序的容器。有序指的是存放顺序。提供了下标的概念（index），围绕下标提供了一堆方法。（add(index,object),addAll(index,collection), remove(index),indexOf(object), lastIndexOf(object), get(index),set(index,object)）</p>
<p>List的实现类有哪些？</p>
<p>ArrayList：底层是数组（内存空间连续），查询快，增删慢。</p>
<p>LinkedList：底层是链表，增删快，查询慢。</p>
<p>Vector：线程安全。</p>
<p><strong>List的遍历方法：</strong></p>
<p>for循环</p>
<p>for each</p>
<p><strong>迭代器</strong></p>
<p>Set是什么？</p>
<p>答：set是一个接口，继承于Collection。用来描述不重复的容器。</p>
<p>Set的实现类有哪些？</p>
<p>HashSet：无序不重复。要求容器里的元素实现了equals方法。</p>
<p>LinkedHashSet：有序不重复。有序指的是存放顺序。也需要元素实现equals放法。</p>
<p>TreeSet：有序不重复。有序指的是内容有序。</p>
<h3 id="treeset-是一个set的实现类">TreeSet 是一个Set的实现类</h3>
<p>TreeSet是一个不重复的容器，而且内容有序。靠Comparable或者Comparator来实现比较，确定是否重复以及谁大谁小。</p>
<p>TreeSet有2大类创建方式：</p>
<ol>
<li>自然排序。 元素本身带有比较方法（本质是元素实现了Comparable接口）</li>
<li>比较器排序。元素本身不具备比较的能力，比较帮元素比较大小。</li>
</ol>
<p>TreeSet底层靠的二叉树来实现内容有序。小的元素放在树的左分支上，大的放在右分支上。读取元素时，TreeSet使用中序遍历的方式读取元素。</p>
<p>TreeSet添加元素以及删除元素和HashSet一样。</p>
<h3 id="小节-2">小节</h3>
<p>Collection描述一个容器</p>
<p>​	List：有序容器，可重复</p>
<p>​		ArrayList： 数组</p>
<p>​		LinkedList： 链表</p>
<p>​		Vector：数组</p>
<p>​	Set：不可重复，通常是无序的。</p>
<p>​		HashSet：普通集合</p>
<p>​		LinkedHashSet：存放顺序有序，不可重复</p>
<p>​		TreeSet：内容有序，不可重读</p>
<h2 id="map接口">Map（接口）</h2>
<p>Map是用来描述一个容器，用来描述一个键值对容器。</p>
<p>Map的特点：键不允许重复。</p>
<p>Map和Colletion是平级的。Map数据键值对接口中的根接口。</p>
<ol>
<li>
<p>添加元素到Map中</p>
<p><strong>put(key, value)</strong> //往Map中存放元素，如果Map中已经有这个key了，会覆盖。如果Map中没有这个key，会把这个键值对存入map</p>
<p>putAll(Map map) //把另外一个map中的元素全部添加到当前map中，如果有key已经存在了，会产生覆盖。</p>
</li>
<li>
<p>移除元素</p>
<p><strong>remove(key)</strong> //根据key移除对应的键值对。</p>
</li>
<li>
<p>修改元素</p>
<p>put(key, value) //如果Map中已经有这个key了，会覆盖. 如果没有就是添加</p>
</li>
<li>
<p>查看Map</p>
<p><strong>size()</strong> //查看里面有多少键值对</p>
<p>containsKey(key) //查看是否有某个key</p>
<p>containsValue(value) //查看是否有某个value</p>
<p><strong>get(key)</strong> //获取key对应的值。</p>
<p><strong>keySet()</strong> //获取所有的key</p>
<p>values() //获取所有的value</p>
<p><strong>entrySet</strong> //获取键值对集合</p>
</li>
</ol>
<h2 id="map的实现类">Map的实现类</h2>
<h3 id="hashmap">HashMap</h3>
<p>HashMap是一个普通的Map。</p>
<h4 id="创建hashmap">创建HashMap</h4>
<ol>
<li>HashMap()  创建一个空的Map，初始容量是16， 加载因子是0.75</li>
<li>HashMap(int capacity) 创建一个空的Map， 初始容量为指定的容量，加载因子是0.75</li>
<li>HashMap(int capacity, float loadFactor) 创建一个空的Map，初始容量和加载因子由参数指定。</li>
<li>HashMap(Map map) 创建一个包含指定键值对的Map。</li>
</ol>
<h3 id="hashmap的使用">HashMap的使用</h3>
<p>增删改查 见Map的API</p>
<h3 id="map的遍历">Map的遍历</h3>
<p>假定有如下Map：</p>
<pre><code class="language-java">Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
map.put(&quot;one&quot;, 100);
map.put(&quot;two&quot;, 88);
map.put(&quot;three&quot;, 96);
map.put(&quot;four&quot;, 88);
</code></pre>
<p>for each遍历</p>
<pre><code class="language-java">Set&lt;String&gt; keys = map.keySet();
for(String key : keys) {
	System.out.println(key+ &quot;----&quot; + map.get(key));
}
</code></pre>
<p>使用迭代器遍历</p>
<pre><code class="language-java">Iterator&lt;String&gt; it = keys.iterator();
while(it.hasNext()) {
	String key = it.next();
	int value = map.get(key);
	System.out.println(key + &quot;===&quot; + value);
}
</code></pre>
<p>for each遍历键值对</p>
<pre><code class="language-java">Set&lt;Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();
for(Entry&lt;String, Integer&gt; e : entries) {
	System.out.println(e.getKey()+ &quot;__&quot;+ e.getValue());
}
</code></pre>
<blockquote>
<p>Entry是专门服务于Map的类。它代表键值对对象，内部含有键和值。如果要取出键和值，使用getKey()以及getValue().</p>
<p>Entry本质上Map中内部类。</p>
</blockquote>
<p>迭代器遍历键值对</p>
<pre><code class="language-java">Iterator&lt;Entry&lt;String,Integer&gt;&gt; it2 = entries.iterator();
while(it2.hasNext()) {
	Entry&lt;String, Integer&gt; e = it2.next();
	System.out.println(e.getKey()+&quot;  &quot;+e.getValue());
}
</code></pre>
<h4 id="linkedhashmap">LinkedHashMap</h4>
<p>存放顺序有序的Map。特点：存放顺序有序，键不能重复。</p>
<h4 id="treemap">TreeMap</h4>
<p>key的内容有序的Map。特点：key的内容有序，键不能重复。</p>
<h4 id="hashtable">HashTable</h4>
<p>它与HashMap非常类似，只不过HashTable是线程安全的。</p>
]]></content>
    </entry>
</feed>